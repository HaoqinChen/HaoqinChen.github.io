<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1ST KISS</title>
      <link href="/posts/380c7def.html"/>
      <url>/posts/380c7def.html</url>
      
        <content type="html"><![CDATA[<h1 id="1ST-KISS"><a href="#1ST-KISS" class="headerlink" title="1ST KISS"></a>1ST KISS</h1><p>一部 穿越，爱情 题材的电影</p><p>剧情的节奏是有点任务式的推进，不会进行相关设定的完善，就是非常的直截了当，回到过去去拯救自己那个很重要的人，发现依旧是爱着</p><p>同时也是在思考，为什么相爱的人最后会变成无法共处呢？可能爱情也是需要悉心的运营吧，只靠心动的爱情会被一个个不心动的瞬间将爱情磨灭，只有珍惜爱护，懂得如何去相处，才能获得长长久久的情感</p><p>其实电影里也没说为什么重来一次的婚姻生活会变得那么好，其实我觉得就是男主知道了自己的结局，同时也感受到女主的爱，相爱的人也许只要有一方懂得去运营，抱着随时都会失去的心态而去守护的吧，两个人相爱的前提下这份婚姻生活还是可以运营很久的吧</p><p>感觉还是很中规中矩的电影，毕竟没怎么在剧情设计上下功夫<br><img src="https://image.haoqin.vip/2025/08/630e18e623b8690ec35293954be4a1e3.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TP一年记</title>
      <link href="/posts/6571f46f.html"/>
      <url>/posts/6571f46f.html</url>
      
        <content type="html"><![CDATA[<h1 id="TP一年记"><a href="#TP一年记" class="headerlink" title="TP一年记"></a>TP一年记</h1><p>挑选了一个宿命般的日子离职，去年的这个周的周一，我正式走上工作，而如今的一年后的周五，我正式结束了自己在TP的一年。<br>尽管TP在网上的风评很差，但我自己实际的经历体验其实还好，遇到了还不错的组，能够不用直面很多的压力，压力最大的时候应该就是答辩前的一段时间，还有在做tpm头一次要公司级汇报的时候，那一次汇报让自己想着后续的日子要是时不时来上几遭，实在是有点顶不住。<br>在TP的工作，可能最大的感触，就是很多工作，做归做，可能最后也米有什么实际的意义，就堆到某个无人问津的角落去了。TP简单的人际关系，可能是我未来再也难以遇到的职场人际关系了，还有一个好处是，工作与生活的分割很干脆利落，虽然我们总是在吐槽内网，但也正是这道内网，隔离了工作对我们生活的袭扰，确实能够下班就是下班，少去了好多的烦恼。<br>虽然在TP感觉也没学习到太多技能，但终究顺利地过完了一年，忘记过程的不愉快，向着新生活继续迈进了！<br><img src="https://image.haoqin.vip/2025/07/0d23323fa01d1ca8ab158025fffda749.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>82年生的金智英</title>
      <link href="/posts/84637e70.html"/>
      <url>/posts/84637e70.html</url>
      
        <content type="html"><![CDATA[<h1 id="82年生的金智英"><a href="#82年生的金智英" class="headerlink" title="82年生的金智英"></a>82年生的金智英</h1><p>阅读前，其实并不知道这本书的主题是什么，看着看着才知道是想通过金智英经历的一生去阐述韩国女性在这几十年内所受到的压迫<br>身为一名男性，在现在的舆论氛围下谈论女性权利等话题其实是不太好的，容易陷入论战。其实不太了解韩国女性是否就是如金智英一般，感觉将各种可能受到的压迫都受了一遍，同时又为了展现不同维度的压迫，又要给予其一定的自由和发展，让她能够进一步去体验可能一些女性都还没有机会体验的压迫。<br>在这个过程中，其实能够感受到个体抗争的一种无力感，如果社会氛围并没有改变的话，个人的反抗就显得很微薄，甚至会在一次次失败中慢慢无力发声，最后金智英的潜意识选择用她亲近的女性来为她发声，在荒诞中控诉；而最后精神科医生的想法，”一定要找未婚单身的才行”，其实也是在揭示若要改变，可能需要从社会规则或者体制中入手，不然依旧是步履蹒跚<br>我其实也很难说什么，只能说在自己的认知里尽可能地去尊重做好对待他人，有些可能已经成为现实的东西，不知道怎么说，在接受中度过？也是一种逃避，不然有时候无视现实，谈谈谈，会不会更受伤呢？<img src="https://image.haoqin.vip/2025/07/68fe2d60e41aa314f9d10d7cfb8aa7cf.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fei宅警告</title>
      <link href="/posts/90464dc2.html"/>
      <url>/posts/90464dc2.html</url>
      
        <content type="html"><![CDATA[<p>记录体重变化，确实宛如过山车一样，23年的下定决定，难得的改变了自己，后来一个过年后，却愈发迷失，失去了变好的动力，而工作后更是放纵，让自己的身体愈发不行，以此记录下吧，看看未来的自己是否能够重回那个稍微健康的自己呢？</p><!-- BMI信息显示区域 --><div id="bmi-info">  <h3>最新BMI指标</h3>  <div class="bmi-content">    <div class="bmi-item">      <span class="label">最新体重：</span>      <span class="value" id="latestWeight">--</span>      <span class="unit">kg</span>    </div>    <div class="bmi-item">      <span class="label">身高：</span>      <span class="value">1.80</span>      <span class="unit">m</span>    </div>    <div class="bmi-item">      <span class="label">BMI指数：</span>      <span class="value" id="bmiValue">--</span>    </div>    <div class="bmi-item">      <span class="label">健康等级：</span>      <span class="value" id="bmiLevel">--</span>    </div>    <div class="bmi-item">      <span class="label">记录日期：</span>      <span class="value" id="latestDate">--</span>    </div>  </div></div><!-- 体重图表控件区域 --><div id="chart-container">  <h2 id="chart-title">月平均体重变化趋势</h2>  <div class="chart-status">    <span id="chart-mode-indicator">当前显示: 月平均体重</span>  </div>  <div class="range-controls">    <label>起始日期 <input type="date" id="startDate"></label>    <label>结束日期 <input type="date" id="endDate"></label>    <button id="applyRange">应用</button>    <button id="recent7">最近7天</button>    <button id="recent30">最近30天</button>    <button id="showAll">显示全部</button>  </div>  <!-- 统计期间和体重变化 - 放在筛选按钮和图表之间 -->  <div class="chart-stats-top">    <div class="stats-item">      <span class="label">统计期间：</span>      <span class="value" id="statsPeriod">--</span>    </div>    <div class="stats-item">      <span class="label">体重变化：</span>      <span class="value" id="weightChange">--</span>      <span class="unit">kg</span>    </div>  </div>  <!-- 图表容器，固定高度 -->  <div class="chart-wrapper">    <canvas id="weightChart"></canvas>  </div>  <!-- 三个体重指标 - 放在图表下方 -->  <div class="chart-stats-bottom">    <div class="stats-item">      <span class="label">起始体重：</span>      <span class="value" id="startWeight">--</span>      <span class="unit">kg</span>    </div>    <div class="stats-item">      <span class="label">结束体重：</span>      <span class="value" id="endWeight">--</span>      <span class="unit">kg</span>    </div>    <div class="stats-item">      <span class="label">平均体重：</span>      <span class="value" id="avgWeight">--</span>      <span class="unit">kg</span>    </div>  </div></div><script src="https://cdn.jsdelivr.net/npm/chart.js"></script><script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script><script>  // 修改为直接读取CSV文件  const csvUrl = "/weight/weight.csv";  let rawData = [], chart = null;  const HEIGHT = 1.8; // 身高固定为1.8米  let isShowingMonthlyAverage = true; // 默认显示月平均数据  let currentFilteredData = []; // 当前过滤的数据  // 清理版CSV解析函数  function parseCSV(csvText) {    const lines = csvText.trim().split('\n');    const data = [];    // 跳过第一行（标题行）    for (let i = 1; i < lines.length; i++) {      const line = lines[i].trim();      if (!line) continue; // 跳过空行      const columns = line.split(',');      if (columns.length >= 2) {        const dateStr = columns[0].trim();        const weightStr = columns[1].trim();        // 解析日期        let date;        if (dateStr.includes('/')) {          // 处理 2025/7/30 格式          const parts = dateStr.split('/');          if (parts.length === 3) {            const year = parts[0];            const month = parts[1].padStart(2, '0');            const day = parts[2].padStart(2, '0');            const isoDateStr = `${year}-${month}-${day}`;            date = new Date(isoDateStr + 'T12:00:00');          }        } else if (dateStr.includes('-')) {          // 处理 2025-07-30 格式          date = new Date(dateStr + 'T12:00:00');        }        const weight = parseFloat(weightStr);        // 验证数据有效性        if (!isNaN(weight) && date && !isNaN(date.getTime())) {          const formattedDate = date.toISOString().slice(0, 10);          const record = {            日期: formattedDate,            体重: weight,            dateObj: date          };          data.push(record);        }      }    }    return data;  }  // 获取月度平均体重数据  function getMonthlyAverageData(data) {    if (!data || data.length === 0) return [];    // 按月分组数据    const monthlyGroups = {};    data.forEach(item => {      const yearMonth = item.日期.substring(0, 7);      if (!monthlyGroups[yearMonth]) {        monthlyGroups[yearMonth] = [];      }      monthlyGroups[yearMonth].push(item.体重);    });    // 计算每月平均值    const monthlyAverages = Object.keys(monthlyGroups).map(yearMonth => {      const weights = monthlyGroups[yearMonth];      const avgWeight = weights.reduce((sum, weight) => sum + weight, 0) / weights.length;      return {        yearMonth: yearMonth,        dateObj: new Date(yearMonth + '-15T12:00:00'),        avgWeight: parseFloat(avgWeight.toFixed(1))      };    });    // 按日期排序    return monthlyAverages.sort((a, b) => a.dateObj - b.dateObj);  }  // 更新体重变化统计信息  function updateWeightStats(data) {    if (!data || data.length === 0) {      // 清空显示      document.getElementById('statsPeriod').textContent = '--';      document.getElementById('startWeight').textContent = '--';      document.getElementById('endWeight').textContent = '--';      document.getElementById('weightChange').textContent = '--';      document.getElementById('avgWeight').textContent = '--';      return;    }    const startRecord = data[0];    const endRecord = data[data.length - 1];    const startWeight = startRecord.体重;    const endWeight = endRecord.体重;    const weightChange = endWeight - startWeight;    const avgWeight = data.reduce((sum, item) => sum + item.体重, 0) / data.length;    // 统一显示具体的时间范围    const periodText = `${startRecord.日期} 至 ${endRecord.日期}`;    // 更新显示    document.getElementById('statsPeriod').textContent = periodText;    document.getElementById('startWeight').textContent = startWeight;    document.getElementById('endWeight').textContent = endWeight;    document.getElementById('avgWeight').textContent = avgWeight.toFixed(1);    // 更新体重变化，添加颜色和符号    const weightChangeElement = document.getElementById('weightChange');    const changeText = (weightChange >= 0 ? '+' : '') + weightChange.toFixed(1);    weightChangeElement.textContent = changeText;    // 根据变化量设置颜色    if (weightChange > 0) {      weightChangeElement.style.color = '#dc3545'; // 红色 - 增重      weightChangeElement.style.fontWeight = 'bold';    } else if (weightChange < 0) {      weightChangeElement.style.color = '#28a745'; // 绿色 - 减重      weightChangeElement.style.fontWeight = 'bold';    } else {      weightChangeElement.style.color = '#6c757d'; // 灰色 - 无变化      weightChangeElement.style.fontWeight = 'normal';    }  }  // 更新图表标题和状态指示器  function updateChartStatus() {    const titleElement = document.getElementById('chart-title');    const indicatorElement = document.getElementById('chart-mode-indicator');    if (isShowingMonthlyAverage) {      titleElement.textContent = '月平均体重变化趋势';      indicatorElement.textContent = '当前显示: 月平均体重';      indicatorElement.className = 'monthly-mode';    } else {      titleElement.textContent = '每日体重记录变化图';      indicatorElement.textContent = '当前显示: 每日体重记录';      indicatorElement.className = 'daily-mode';    }  }  // 创建稳定的图表配置  function createChartConfig(type, data, options) {    return {      type: type,      data: data,      options: {        responsive: true,        maintainAspectRatio: false,        interaction: {          intersect: false,          mode: 'index'        },        animation: {          duration: 300 // 减少动画时间        },        ...options      }    };  }  // 渲染月度平均体重图表（曲线图）  function renderMonthlyChart(data) {    const monthlyData = getMonthlyAverageData(data);    currentFilteredData = data;    updateWeightStats(data);    if (chart) {      chart.destroy();      chart = null;    }    const dataPoints = monthlyData.map(item => ({      x: item.dateObj,      y: item.avgWeight    }));    const chartData = {      datasets: [{        label: '月平均体重 (kg)',        data: dataPoints,        borderColor: '#ff6384',        backgroundColor: 'rgba(255, 99, 132, 0.1)',        fill: true,        pointRadius: 6,        pointHoverRadius: 8,        pointBackgroundColor: '#ff6384',        pointBorderColor: '#ffffff',        pointBorderWidth: 2,        tension: 0.3,        borderWidth: 3      }]    };    const chartOptions = {      plugins: {        legend: { display: false },        tooltip: {           callbacks: {            title: function(context) {              const date = new Date(context[0].raw.x);              return date.toLocaleDateString('zh-CN', {                year: 'numeric',                month: '2-digit'              });            },            label: function(context) {              const avgWeight = context.raw.y;              const bmi = calculateBMI(avgWeight, HEIGHT);              const bmiInfo = getBMILevel(parseFloat(bmi));              return [                `月平均体重: ${avgWeight} kg`,                `BMI: ${bmi} (${bmiInfo.level})`              ];            }          }        }      },      scales: {        x: {          type: 'time',          time: {            unit: 'month',            displayFormats: {              month: 'yyyy-MM'            }          },          title: { display: true, text: '月份' }        },        y: {           title: { display: true, text: '体重 (kg)' },          beginAtZero: false,          ticks: {            callback: function(value) {              return value + ' kg';            }          }        }      }    };    // 创建图表    const ctx = document.getElementById('weightChart').getContext('2d');    chart = new Chart(ctx, createChartConfig('line', chartData, chartOptions));    isShowingMonthlyAverage = true;    updateChartStatus();  }  // 渲染每日体重图表  function renderDailyChart(filteredData) {    currentFilteredData = filteredData;    updateWeightStats(filteredData);    // 使用时间轴数据格式    const dataPoints = filteredData.map(item => ({      x: item.dateObj,      y: item["体重"]    }));    if (chart) {      chart.destroy();      chart = null;    }    // 根据数据点数量和时间跨度动态调整显示策略    const dataLength = filteredData.length;    const timeSpanDays = dataLength > 1 ?       Math.ceil((filteredData[filteredData.length - 1].dateObj - filteredData[0].dateObj) / (1000 * 60 * 60 * 24)) : 1;    // 动态调整点的显示    let pointRadius, pointHoverRadius;    if (dataLength > 50) {      pointRadius = 1;                pointHoverRadius = 3;         } else if (dataLength > 30) {      pointRadius = 3;      pointHoverRadius = 5;    } else {      pointRadius = 4;      pointHoverRadius = 6;    }    // 动态调整X轴标签策略    let xAxisConfig;    if (timeSpanDays <= 7) {      xAxisConfig = {        type: 'time',        time: {          unit: 'day',          displayFormats: {            day: 'MM-dd'          }        },        title: { display: true, text: '日期' },        ticks: {          autoSkip: false,          maxRotation: 45,          minRotation: 0,          source: 'data'        }      };    } else if (timeSpanDays <= 30) {      xAxisConfig = {        type: 'time',        time: {          unit: 'day',          displayFormats: {            day: 'MM-dd'          }        },        title: { display: true, text: '日期' },        ticks: {          maxTicksLimit: Math.min(12, Math.ceil(dataLength / 2)),          autoSkip: true,          maxRotation: 45,          minRotation: 0,          source: 'data'        }      };    } else if (timeSpanDays <= 90) {      xAxisConfig = {        type: 'time',        time: {          unit: 'week',          displayFormats: {            week: 'MM-dd'          }        },        title: { display: true, text: '日期' },        ticks: {          maxTicksLimit: 15,          autoSkip: true,          maxRotation: 45,          minRotation: 0        }      };    } else {      xAxisConfig = {        type: 'time',        time: {          unit: 'month',          displayFormats: {            month: 'yyyy-MM'          }        },        title: { display: true, text: '日期' },        ticks: {          maxTicksLimit: 12,          autoSkip: true,          maxRotation: 45,          minRotation: 0        }      };    }    const chartData = {      datasets: [{        label: '体重 (kg)',        data: dataPoints,        borderColor: '#007bff',        backgroundColor: 'rgba(0,123,255,0.08)',        fill: true,        pointRadius: pointRadius,        pointHoverRadius: pointHoverRadius,        pointBackgroundColor: '#007bff',        pointBorderColor: '#ffffff',        pointBorderWidth: pointRadius > 1 ? 1 : 0.5,        tension: 0.2,        borderWidth: 2      }]    };    const chartOptions = {      plugins: {        legend: { display: false },        tooltip: {           enabled: true,          callbacks: {            title: function(context) {              const date = new Date(context[0].raw.x);              return date.toLocaleDateString('zh-CN', {                year: 'numeric',                month: '2-digit',                day: '2-digit'              });            },            label: function(context) {              const weight = context.raw.y;              const bmi = calculateBMI(weight, HEIGHT);              const bmiInfo = getBMILevel(parseFloat(bmi));              return [                `体重: ${weight} kg`,                `BMI: ${bmi} (${bmiInfo.level})`              ];            }          }        }      },      scales: {        x: xAxisConfig,        y: {           title: {             display: true,             text: '体重 (kg)'           },           beginAtZero: false,          ticks: {            callback: function(value) {              return value + ' kg';            }          }        }      }    };    // 创建图表    const ctx = document.getElementById('weightChart').getContext('2d');    chart = new Chart(ctx, createChartConfig('line', chartData, chartOptions));    isShowingMonthlyAverage = false;    updateChartStatus();  }  // 数据加载  fetch(csvUrl)    .then(res => res.text())    .then(csvText => {      rawData = parseCSV(csvText);      // 按日期排序      rawData.sort((a, b) => a.dateObj - b.dateObj);      updateBMIInfo();      renderMonthlyChart(rawData);      initDateInputs();    })    .catch(e => {      document.getElementById('chart-container').innerHTML +=        '<div style="color:red;">数据加载失败: ' + e.message + '</div>';    });  // 计算BMI指数  function calculateBMI(weight, height) {    return (weight / (height * height)).toFixed(1);  }  // 获取BMI等级和对应的颜色  function getBMILevel(bmi) {    if (bmi < 18.5) {      return { level: '偏瘦', color: '#17a2b8', bgColor: 'rgba(23, 162, 184, 0.1)' };    } else if (bmi < 24) {      return { level: '正常', color: '#28a745', bgColor: 'rgba(40, 167, 69, 0.1)' };    } else if (bmi < 28) {      return { level: '偏胖', color: '#ffc107', bgColor: 'rgba(255, 193, 7, 0.1)' };    } else {      return { level: '肥胖', color: '#dc3545', bgColor: 'rgba(220, 53, 69, 0.1)' };    }  }  // 更新BMI信息显示  function updateBMIInfo() {    if (rawData.length === 0) return;    const latestRecord = rawData[rawData.length - 1];    const weight = latestRecord.体重;    const bmi = calculateBMI(weight, HEIGHT);    const bmiInfo = getBMILevel(parseFloat(bmi));    document.getElementById('latestWeight').textContent = weight;    document.getElementById('bmiValue').textContent = bmi;    document.getElementById('bmiLevel').textContent = bmiInfo.level;    document.getElementById('latestDate').textContent = latestRecord.日期;    const bmiLevelElement = document.getElementById('bmiLevel');    bmiLevelElement.style.color = bmiInfo.color;    bmiLevelElement.style.fontWeight = 'bold';    const bmiInfoElement = document.getElementById('bmi-info');    bmiInfoElement.style.borderLeftColor = bmiInfo.color;    bmiInfoElement.style.backgroundColor = bmiInfo.bgColor;  }  function filterData(start, end) {    return rawData.filter(item =>      (!start || item.dateObj >= start) && (!end || item.dateObj <= end)    );  }  function initDateInputs() {    if(rawData.length === 0) return;    document.getElementById('startDate').value = rawData[0].日期;    document.getElementById('endDate').value = rawData[rawData.length - 1].日期;  }  // 重置到全部数据的函数  function resetToAllData() {    if(rawData.length === 0) return;    document.getElementById('startDate').value = rawData[0].日期;    document.getElementById('endDate').value = rawData[rawData.length - 1].日期;    renderMonthlyChart(rawData);  }  // 应用日期范围  document.getElementById('applyRange').onclick = function() {    const startVal = document.getElementById('startDate').value;    const endVal = document.getElementById('endDate').value;    const start = startVal ? new Date(startVal) : null;    const end = endVal ? new Date(endVal) : null;    const isAllData =       startVal === rawData[0].日期 &&       endVal === rawData[rawData.length - 1].日期;    const filteredData = filterData(start, end);    if (isAllData) {      renderMonthlyChart(filteredData);    } else {      renderDailyChart(filteredData);    }  };  // 最近7天按钮  document.getElementById('recent7').onclick = function() {    if(rawData.length === 0) return;    const maxDate = rawData.reduce((a,b)=>a.dateObj > b.dateObj ? a : b).dateObj;    const minDate = new Date(maxDate);    minDate.setDate(minDate.getDate() - 6);    document.getElementById('startDate').value = minDate.toISOString().slice(0,10);    document.getElementById('endDate').value = maxDate.toISOString().slice(0,10);    const filteredData = filterData(minDate, maxDate);    renderDailyChart(filteredData);  };  // 最近30天按钮  document.getElementById('recent30').onclick = function() {    if(rawData.length === 0) return;    const maxDate = rawData.reduce((a,b)=>a.dateObj > b.dateObj ? a : b).dateObj;    const minDate = new Date(maxDate);    minDate.setDate(minDate.getDate() - 29);    document.getElementById('startDate').value = minDate.toISOString().slice(0,10);    document.getElementById('endDate').value = maxDate.toISOString().slice(0,10);    const filteredData = filterData(minDate, maxDate);    renderDailyChart(filteredData);  };  // 显示全部数据按钮  document.getElementById('showAll').onclick = function() {    resetToAllData();  };</script><style>/* BMI信息区域样式 */#bmi-info {  margin: 20px 0;  padding: 20px;  background: #f8f9fa;  border: 1px solid #e9ecef;  border-left: 4px solid #007bff;  border-radius: 8px;  transition: all 0.3s ease;}#bmi-info h3 {  margin: 0 0 15px 0;  color: #333;  font-size: 1.2em;  font-weight: 600;}.bmi-content {  display: grid;  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));  gap: 12px;}.bmi-item {  display: flex;  align-items: center;  font-size: 0.95em;}.bmi-item .label {  color: #666;  font-weight: 500;  min-width: 80px;}.bmi-item .value {  font-weight: 600;  color: #333;  margin-right: 4px;}.bmi-item .unit {  color: #888;  font-size: 0.9em;}/* 图表容器样式 */#chart-container {  margin: 20px 0;  padding: 20px;  border: 1px solid #e9ecef;  border-radius: 8px;  background: white;  box-shadow: 0 2px 5px rgba(0,0,0,0.05);}#chart-container h2 {  margin-bottom: 5px;  color: #333;  text-align: center;}/* 图表状态指示器样式 */.chart-status {  text-align: center;  margin-bottom: 15px;  font-size: 0.9em;}#chart-mode-indicator {  display: inline-block;  padding: 4px 10px;  border-radius: 12px;  font-weight: 500;}.monthly-mode {  background-color: rgba(255, 99, 132, 0.1);  color: #ff6384;}.daily-mode {  background-color: rgba(0, 123, 255, 0.1);  color: #007bff;}/* 筛选控件样式 */.range-controls {  margin: 20px 0;  padding: 15px;  background: #f8f9fa;  border-radius: 8px;}.range-controls label {  margin-right: 15px;  font-weight: 500;}.range-controls input {  margin-left: 5px;  margin-right: 15px;  padding: 5px 8px;  border: 1px solid #ddd;  border-radius: 4px;}.range-controls button {  margin-right: 8px;  padding: 6px 12px;  background: #007bff;  color: white;  border: none;  border-radius: 4px;  cursor: pointer;  transition: background 0.2s;}.range-controls button:hover {  background: #0056b3;}/* 为显示全部按钮添加特殊样式 */#showAll {  background: #28a745 !important;}#showAll:hover {  background: #218838 !important;}/* 图表上方统计信息 - 在筛选按钮和图表之间 */.chart-stats-top {  display: flex;  justify-content: space-around;  margin: 15px 0;  padding: 12px 20px;  background: rgba(23, 162, 184, 0.05);  border: 1px solid rgba(23, 162, 184, 0.2);  border-radius: 6px;}/* 图表下方统计信息 - 在图表下方 */.chart-stats-bottom {  display: flex;  justify-content: space-around;  margin: 15px 0 0 0;  padding: 12px 20px;  background: rgba(23, 162, 184, 0.05);  border: 1px solid rgba(23, 162, 184, 0.2);  border-radius: 6px;}.chart-stats-top .stats-item,.chart-stats-bottom .stats-item {  display: flex;  align-items: center;  font-size: 0.95em;  flex: 1;  justify-content: center;}.chart-stats-top .stats-item .label,.chart-stats-bottom .stats-item .label {  color: #666;  font-weight: 500;  margin-right: 8px;}.chart-stats-top .stats-item .value,.chart-stats-bottom .stats-item .value {  font-weight: 600;  color: #333;  margin-right: 4px;}.chart-stats-top .stats-item .unit,.chart-stats-bottom .stats-item .unit {  color: #888;  font-size: 0.9em;}/* 关键修复：图表容器固定高度并防止拉伸 */.chart-wrapper {  position: relative;  width: 100%;  height: 400px;  margin: 15px 0;  overflow: hidden;}#weightChart {  position: absolute !important;  top: 0;  left: 0;  width: 100% !important;  height: 100% !important;  max-width: none !important;  max-height: none !important;}/* 响应式设计 */@media (max-width: 768px) {  .bmi-content {    grid-template-columns: 1fr;  }  .bmi-item {    justify-content: space-between;  }  .chart-stats-top,  .chart-stats-bottom {    flex-direction: column;    gap: 8px;  }  .chart-stats-top .stats-item,  .chart-stats-bottom .stats-item {    justify-content: space-between;  }  .chart-wrapper {    height: 300px;  }}@media (max-width: 576px) {  .range-controls {    display: flex;    flex-direction: column;    align-items: flex-start;  }  .range-controls label, .range-controls button {    margin-bottom: 10px;  }  .range-controls button {    width: 100%;    margin-right: 0;  }  .chart-wrapper {    height: 250px;  }}</style>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>地球尽头的温室</title>
      <link href="/posts/f9b7c6fe.html"/>
      <url>/posts/f9b7c6fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="地球尽头的温室"><a href="#地球尽头的温室" class="headerlink" title="地球尽头的温室"></a>地球尽头的温室</h1><p>好久没有这么完整地越读这么一本纸质书<br>感觉质量还是挺不错的，从几个人的视角逐步展开，将粉尘时代的爆发，过程与结束后的探寻过程进行了剖析，有点探寻历史真相的过程，让读者能够一直保持好奇<br>不过一开始确实没有想到瑞秋和知秀两个人的感情走向，世界毁灭的进程还与两人的情感状态息息相关，有那么点套路化了。<br>同时，也想表达那种，拯救世界的人往往不为人知，奉献的的人永远倒在第一线，反而没有很多后代能够为他们发声，在黑暗的环境中最终存活的人，很多人带有罪行……</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git小悟</title>
      <link href="/posts/2e964b2d.html"/>
      <url>/posts/2e964b2d.html</url>
      
        <content type="html"><![CDATA[<h1 id="分支的意义"><a href="#分支的意义" class="headerlink" title="分支的意义"></a>分支的意义</h1><p>在团队合作进行代码编写工作的时候，可以使用新建分支的方法来进行管理本地的代码，开发到一定程度的时候再同步到git上。</p><h1 id="分支概念"><a href="#分支概念" class="headerlink" title="分支概念"></a>分支概念</h1><p>在git中，<code>head</code>指向的是目前所在的分支，<code>master</code>一般指的是我们目前代码库的主分支，每次<code>commit</code>都是在原来这一条分支上进行延伸，伸展出来一个又一个的节点。</p><p>如果在某个节点新建了分支<code>dev</code>，那么这个节点就会出现分叉，切换到<code>dev</code>分支后提交的每次<code>commit</code>都是在这个分支上进行延伸</p><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p>在简单的情况下，进行分支的合并，能够汇总我们的改动结果到<code>master</code>上，使用的命令为：<code>git merge [branch]</code>，用于合并指定分支到当前分支；此时为“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交。</p><p>但是，如果<code>master</code>已经出现跟<code>dev</code>中对同个文件的改动的提交了，那么此时会出现冲突。<code>git status</code>也可以告诉我们冲突的文件。</p><h1 id="悟了悟了"><a href="#悟了悟了" class="headerlink" title="悟了悟了"></a>悟了悟了</h1><p>团队合作时，常规的git操作：</p><ol><li><code>revert</code>清除掉目前所有不需要的文件改动</li><li><code>commit</code>本次所需要提交的改动</li><li><code>stash</code>暂存目前还不想提交的改动（<code>push</code>完之后可以把他们放回来）</li><li>使用<code>fetch</code>，然后<code>rebase</code>，这样子正常来说我们的提交指针就可以在远程仓库的后面了</li><li>最后<code>push</code>！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学生与打工人</title>
      <link href="/posts/848ad235.html"/>
      <url>/posts/848ad235.html</url>
      
        <content type="html"><![CDATA[<h2 id="顺风来去"><a href="#顺风来去" class="headerlink" title="顺风来去"></a>顺风来去</h2><p>这一天从早晨的顺风车开始，遇到了以为老乡，而且还是98届的华工建筑系校友，这世间缘分真的是一种很奇妙的东西，聊着各色家常，从行业到孩子，师兄现在在开顺风车，但他也在最需要的年份里挣下了深圳的一套房，其实现在无论压力大否，至少已经不是很致命，一套大城市的房可以让很多人在前进的路上有了很强大的支撑。</p><h2 id="研究生的苦"><a href="#研究生的苦" class="headerlink" title="研究生的苦"></a>研究生的苦</h2><p>确实，我是一个擅长遗忘不开心的人，曾经在log那手下的压力与一些不愉快的经历，在过去之后很自然而然地被我埋入记忆的深处。在这阳光明媚的日子里，跟着同门一块在这山间野餐，本该是一件很惬意的事情。但是，他还是出现了，用一个有一个的连环call，把尚未脱离他的人们折磨地难以有一颗玩乐的心灵。</p><p>为何人们要如此地被束缚着？何尝不是权力的严重不对等，资本家在历史的长河中尚且也算是一个阶段的新进的产物，但这奴隶主般的封建存在却让学子们没有反抗的力量，或者说反抗的风险会是那么的高。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赌徒心态</title>
      <link href="/posts/b8264dd.html"/>
      <url>/posts/b8264dd.html</url>
      
        <content type="html"><![CDATA[<p>总感觉自己有一种明知道不行或者风险大的赌徒心态尝试心理，像今天的刮刮乐，一开始抽中个20块钱后，其实可以收手，但最后搞着搞着40块钱就没了，明知道这玩意是一个低概率事件，但却总是想要试试，而且怎么说呢，在遇到这种损失的时候，心中却往往是比较无感的</p><p>在最近的考试里，其实也有这样的心态，有很多常识题，我其实能感觉到不对劲，但偏偏就是有点执拗，想赌一赌，当然基本都赌失败了，这种建立在理智上的认识但却在情感上的冲动，往往会犯下错误</p><p>ETF基金，感情，等等诸如此类，一时的明知不可行而行之。。。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时隔八个月的重返广州</title>
      <link href="/posts/4b8f471.html"/>
      <url>/posts/4b8f471.html</url>
      
        <content type="html"><![CDATA[<h1 id="正文内容"><a href="#正文内容" class="headerlink" title="正文内容"></a>正文内容</h1><p>虽然说深圳和广州距离不远，但毕业之后就一次广州但还没回去过，借着一次考试的机会，回去溜达了一下，不过时间还是紧张，没有进行什么交际活动<br>发现高铁上还可以买到便宜的矿泉水，2块钱，虽然是小瓶装，但已经很可以了，以前傻傻的一路渴着过来：<br><img src="https://image.haoqin.vip/2025/03/1709b9044e87f594269f4dfba59a05a3.webp" alt=""><br>去到远到离谱的竹料，就在传说的钟落潭旁边，那真的不是一般的远，头一次解锁了14号线：<br><img src="https://image.haoqin.vip/2025/03/a2097ed0c3055e6d316c6e3b61288ab4.webp" alt=""><br>但是没有想到这么偏远的路线，在晚上返程的时候还遇到了一大堆人，广州真的一如既往的人挤人，头一次触发了书包被夹事件，还得求助地铁工作人员，最后地铁掉了个头才把我放了出来：<br><img src="https://image.haoqin.vip/2025/03/e32f0cded54b329fbac2aa3bf03eda36.webp" alt=""><br>晚上解锁了在深圳排不上队的西塔老太太，虽然也就那样吧，甜甜的确实奇怪：<br><img src="https://image.haoqin.vip/2025/03/713523a099c3a01455b58dbbca798d67.webp" alt=""><br>第二天的大家福美食店，还是可以的：<br><img src="https://image.haoqin.vip/2025/03/47ddf7b41a54666fde0e4e6dda87c140.webp" alt=""><br><img src="https://image.haoqin.vip/2025/03/4e72dbdf795493d55bc283dba6183857.webp" alt=""><br><img src="https://image.haoqin.vip/2025/03/33b0e1b3855f94d3837940c6366024cd.webp" alt=""><br>最后还去了我一直念叨着，但还没去过的二沙岛，登上了之前一直预约不到的海心桥。二沙岛也是个工位定位，好多过来休闲野餐，放风筝，这里看广州塔的视角还是不错了，用一加的大师模式拍了一张还算是满意的照片：<br><img src="https://image.haoqin.vip/2025/03/8b5b029066a3fbd3cdb19598b7d5c384.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步？同步？</title>
      <link href="/posts/2929faf1.html"/>
      <url>/posts/2929faf1.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很长一段时间里，因为是外行人，我看到js里面的同步/异步的概念，还一直以为 同步 就是多任务并行，而 异步 才是顺序执行，等到今天正儿八经地看下js的异步模型，这才浅浅了解</p><h1 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h1><p>异步（Asynchronous, async）是与同步（Synchronous, sync）相对的概念。</p><p>同步按你的代码顺序执行，异步<strong>不按照代码顺序执行</strong>（不代表并行），异步的执行效率更高。</p><p>在遇到一些耗时时间长的事件时，可以利用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情；</p><p>但这样子主线程不清楚子线程的情况，不处于原先的一个同步状态。</p><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">&#x2F;&#x2F; setTimeout(JavaScript 函数, 等待的毫秒数)setTimeout(function () &#123;    document.getElementById(&quot;demo&quot;).innerHTML&#x3D;&quot;RUNOOB!&quot;;&#125;, 3000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 的异步性体现在其<strong>回调管理机制</strong>而非自身实现异步</p><h2 id="同步执行部分"><a href="#同步执行部分" class="headerlink" title="同步执行部分"></a><strong>同步执行部分</strong></h2><p>Promise 构造函数内的executor函数（即new Promise(fn)中的fn）是<strong>同步执行</strong>的，例如：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">new Promise(resolve &#x3D;&gt; &#123;  console.log(1); &#x2F;&#x2F; 同步代码  resolve(3);&#125;);console.log(2); &#x2F;&#x2F; 输出顺序：1 → 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异步回调部分"><a href="#异步回调部分" class="headerlink" title="异步回调部分"></a>异步回调部分</h2><p>通过<code>.then()</code>注册的回调函数会被放入<strong>微任务队列（Microtask Queue）</strong>，等待当前执行栈清空后才会执行：</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">new Promise(resolve &#x3D;&gt; &#123;  console.log(1);  resolve(3);&#125;).then(num &#x3D;&gt; console.log(num));console.log(2);&#x2F;&#x2F; 输出顺序：1 → 2 → 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以在这里有点进一步加深对 <strong>异步</strong> 的理解，即 <strong>异步 ≠ 并行</strong>：</p><ul><li><strong>异步</strong>：代码执行权交还主线程，回调延迟执行（JS 单线程特性）</li><li><strong>并行</strong>：多线程同时执行（如 Web Worker）</li></ul><h1 id="asnyc"><a href="#asnyc" class="headerlink" title="asnyc"></a>asnyc</h1><p>在JavaScript中，<code>async</code>是一个关键字，用于声明一个异步函数。当你使用<code>async</code>关键字定义一个函数时，这个函数就会成为一个异步函数。异步函数的主要特点是它内部可以使用<code>await</code>关键字来等待一个异步操作的完成，而不会阻塞代码的执行。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">async function myAsyncFunction() &#123;  return &#39;Hello, world!&#39;;&#125;myAsyncFunction().then(result &#x3D;&gt; &#123;  console.log(result); &#x2F;&#x2F; 输出: Hello, world!&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p><strong>使用**</strong><code>await</code><strong>**关键字</strong>‌：在异步函数内部，你可以使用<code>await</code>关键字来等待一个<code>Promise</code>的解决（resolve）或拒绝（reject）。<code>await</code>会暂停异步函数的执行，直到等待的<code>Promise</code>完成，然后继续执行异步函数并返回解决的值。如果<code>Promise</code>被拒绝，则<code>await</code>表达式会抛出一个异常。</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">async function fetchData() &#123;  try &#123;    const response &#x3D; await fetch(&#39;https:&#x2F;&#x2F;api.example.com&#x2F;data&#39;);    const data &#x3D; await response.json();    console.log(data);  &#125; catch (error) &#123;    console.error(&#39;Error fetching data:&#39;, error);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周末加大班的傻子</title>
      <link href="/posts/ab440ddf.html"/>
      <url>/posts/ab440ddf.html</url>
      
        <content type="html"><![CDATA[<h1 id="正文内容"><a href="#正文内容" class="headerlink" title="正文内容"></a>正文内容</h1><p>累死，为了一个跟自己相关度不是特别高的别人的汇报，折腾自己一个周末两天，太痛苦了</p><p>最后也就是喜提60块钱“餐补费”，实在是无言以对，对自己的好处基本约等于没有，还缺少苦劳的可视化界面，也没几个人知道你在这里干死干活的</p><p>成果出来也用处不大，甚至还大概率得被嫌弃</p><p>有毒有毒，下次该摆还是得摆，收益约等于没有，甚至还有风险</p><p>白瞎这好天气了：<br><img src="https://image.haoqin.vip/2025/03/370dbeaebc39317ced168f237afa2578.webp" alt=""></p><p>最后贴个今日版 蜡笔小新，最近还挺喜欢看的，没想到今天就在科兴的库迪看到了：<br><img src="https://image.haoqin.vip/2025/03/8bcf678271618ce821b081e557c0b5c8.webp" alt=""></p><p><img src="https://image.haoqin.vip/2025/03/2dda61bf94423df0fe338d96b37da684.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑等价性</title>
      <link href="/posts/c5145f13.html"/>
      <url>/posts/c5145f13.html</url>
      
        <content type="html"><![CDATA[<h1 id="A推出B"><a href="#A推出B" class="headerlink" title="A推出B"></a>A推出B</h1><p>在逻辑学中，“A推出B”（即蕴含式 $A \rightarrow B$）与“非A或B”（即 $\neg A \vee B$）的等价性是一个基本定理，可通过以下角度理解：</p><ul><li>可以从直接的合并表示来理解：在这种情况下A是真的，那么B一定是真的；然而A是假的时候，无论B是真的还是假的，都不会映像原来的命题。因此，合并上述的情况，那么就是非A或B，你也可以想成非A或A，这就囊括了全部的情况，而A就是等于B</li><li>另外一种逻辑的判断，是否定的角度，该条件的否定命题，就是A且非B，那么在否一次过来的话，就是“非A或B”（即 $\neg A \vee B$）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>傲慢与偏见</title>
      <link href="/posts/58d19a95.html"/>
      <url>/posts/58d19a95.html</url>
      
        <content type="html"><![CDATA[<h1 id="傲慢者的心理与神色"><a href="#傲慢者的心理与神色" class="headerlink" title="傲慢者的心理与神色"></a>傲慢者的心理与神色</h1><p>确实如我平常见到的小说和电视剧的区别，在小说里面会对人物的感情和一些神色动作会有更加进一步的描述</p><p>在电视剧里面，其实达西对伊丽莎白的感情在前期我没有那么直观的感受，但是在书里确实能感受到他的不同，会更加直接的叙述他的感觉，也能很直观的看到他在谈及伊丽莎白时候的不同，剧里实打实的傲慢，但在书里这样的傲慢，在伊丽莎白面前会有所收敛？</p><p>如他会问伊丽莎白为什么不要跳舞，而伊丽莎白对他进行辛辣的讽刺的时候，他也会恭谨地回复，“实在不敢”。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>许多的一个人行为</title>
      <link href="/posts/4f909950.html"/>
      <url>/posts/4f909950.html</url>
      
        <content type="html"><![CDATA[<p>哈哈这个其实也是想测试下图床的上传功能是否正常<br>今天解锁了 一个人火锅行为 40块钱能吃两盘肉和一份牛肉粿条，属实在深圳是很amazing的事了<br><img src="https://image.haoqin.vip/2025/03/ce98412905624ebcbb3e99f9f6e85ada.webp" alt=""><br>牛肉粿条也好好吃，很顶饱，哈哈还专门点了个干炒，没那么喜欢湿炒<br><img src="https://image.haoqin.vip/2025/03/6ea533c5d7650998fb6e285150530306.webp" alt=""><br>离开的时候，还好评给了沙茶酱，确实赚<br><img src="https://image.haoqin.vip/2025/03/cd734191fad10489eebbed4843955109.webp" alt=""></p><p>想想其实一个人还是做过很多网上所说的不建议一个人做（孤单寂寞？）的事：</p><ul><li>一个人吃火锅</li><li>一个人看电影</li><li>一个人看病</li><li>一个人搬家</li><li>一个人去海边</li><li>一个人逛超市（这个不是很常见么？）</li><li>一个人去酒吧</li></ul><p>想不到了，其实也没啥，主观客观下就是一个人的处境了<br>哈哈当然如果有另外一个想要在一块的人陪着，那肯定是人间盛事了</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比重_平均值</title>
      <link href="/posts/9c610bdc.html"/>
      <url>/posts/9c610bdc.html</url>
      
        <content type="html"><![CDATA[<h1 id="比重变化"><a href="#比重变化" class="headerlink" title="比重变化"></a>比重变化</h1><p>今天在看资料分析的时候，注意到平均值和比重这一概念，其实两个还是一致的</p><p>A/B 从比重的角度进行理解，就是A占了B的多少</p><p>如果从平均值的角度进行理解的话，那就是A被分成了B份,因此会得到一个平均值的概念</p><p>而这里使用到的比较核心的公式，是比重的变化，其实也是等价于平均值的数值变化</p><p>$$ 变化 ＝ (a-b) \frac{A}{B} \frac{1}{1+a} $$</p><p>把他拆成三个部分来进行理解的话，也就是说，我们可以先比较两个部分之间的增长率的变化，进行一个初步的判断，至少说是他是一个正增长还是一个负增长，然后还需要判断说 部分 这个a增长率的一个体现。</p><h1 id="平均数增长率"><a href="#平均数增长率" class="headerlink" title="平均数增长率"></a>平均数增长率</h1><p>这个公式其实也相当于上一个公式的变种，平均数也是两个数 相除 的变化，因此也相当于是权重的变化，而增长率是针对 基期 来的，基期乘以增长率就会得到比重的变化值，因此：<br>$$ \frac{A}{B} \frac{1+b}{1+a}增长率 ＝ (a-b) \frac{A}{B} \frac{1}{1+a} $$<br>最后增长率：<br>$$ 增长率 ＝ \frac{a-b}{1+b} $$</p>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板and工作</title>
      <link href="/posts/e9e819b5.html"/>
      <url>/posts/e9e819b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>为了更加方便地进行博文操作，借助deepseek完成了模板的构建，原来模板还可以加入js代码来进行一些定制化操作</p><p>现在的思路是使用Alt+N创建的时候，选中该模板，可以直接输入标题，然后文件就会被重命名</p><p>有点遗憾的是，title作为笔记的属性，提前构建了，没办法在这里同步为文件名</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>最近工作最头疼的一点，就是推进工作很难，涉及到人与人之间的沟通，而自己的地位相对不处于一个高位的状态，导致难以有效的沟通，这无疑是一个很难办的点</p><p>所以这些天确实处于一个被困住，却又没干什么，看似在摸鱼，但心情也不舒服的状态</p><p>本来还以为有机会回学校参加春招，没想到小小的希望后还是失望，还想着回去看看</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/posts/28239a8d.html"/>
      <url>/posts/28239a8d.html</url>
      
        <content type="html"><![CDATA[<h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><p>API（application programming Interface）即应用程序接口</p><p><code>hasattr()</code>函数是<a href="https://so.csdn.net/so/search?q=Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">Python内置函数</a>之一，用于判断对象是否具有指定的属性或方法。它接受两个参数：对象和属性或方法的名称。函数返回一个布尔值，如果对象具有指定的属性或方法，则返回<code>True</code>，否则返回<code>False</code>。</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><strong>面向对象编程</strong>：把一组数据和处理数据的方法组成<strong>对象</strong>，把行为相同的对象归纳为<strong>类</strong>，通过<strong>封装</strong>隐藏对象的内部细节，通过<strong>继承</strong>实现类的特化和泛化，通过<strong>多态</strong>实现基于对象类型的动态分派。</p><p>如果直接打印对象的话，输出的是对象在内存中的地址，也就是说我们定义的变量其实保存的是一个对象在内存中的逻辑地址。</p><p><strong>调用方法</strong>：</p><ul><li>通过类-方法进行调用：<code>Student.play(stu1)</code></li><li>通过对象-方法来进行调用：<code>stu1.play()</code></li></ul><p><strong>初始化方法</strong>，能够完成对对象内存的初始化操作，同时完成对属性赋初始值的操作，<code>__init__</code></p><h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><p>在Python中，以两个下划线<code>__</code>（读作“dunder”）开头和结尾的方法通常都是有特殊用途和意义的方法，我们一般称之为<strong>魔术方法</strong>或<strong>魔法方法</strong>。</p><p>如果我们在打印对象的时候不希望看到对象的地址而是看到我们自定义的信息，可以通过在类中放置<code>__repr__</code>魔术方法来做到，该方法返回的字符串就是用<code>print</code>函数打印对象的时候会显示的内容</p><p>Python为动态语言，我们可以在使用对象时 动态地 为对象添加属性；因此如果想要限制对象的属性，我们可以使用<code>__slots__</code>魔法来指定，例如：<code>__slots__ = (&#39;name&#39;, &#39;age&#39;)</code></p><p><strong>getattribute</strong>()会在调用类的属性时先调用该方法，为了避免陷入无限递归，访问他的属性时，最好使用基类方法来设置属性，使用<code>super().__getattribute__(attr)</code>或<code>object.__getattribute__(self,attr)</code>均可。</p><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>python中@符号也有着重要的作用：一个是表示<strong>修饰符</strong>，另一个则是表示<strong>矩阵乘法(不常用)</strong>。</p><p>用做函数的<strong>修饰符</strong>，可以在模块或者类的定义层内对函数进行修饰；</p><p>出现在函数定义的<strong>前一行</strong>，不允许和函数定义在同一行。</p><p>一个修饰符就是一个函数，它将被修饰的函数作为参数，并返回修饰后的同名函数或其他可调用的东西（如果返回不是一个可调用的对象那么会报错）。示例代码：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">#Example 1def test(func):    print(&quot;a&quot;)    return func()    @test     #从这里可以看出@test等价于 test(xxx())def xxx():    print(&#39;Hello world!&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“（）”小括号，也就是他相当于可以等价于该类的属性，可以直接self.方法名 来进行访问。 而要想实现修改 area 属性的值，还需要为 area 属性添加 setter 方法，就需要用到 setter 装饰器，</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客迁移</title>
      <link href="/posts/f2707009.html"/>
      <url>/posts/f2707009.html</url>
      
        <content type="html"><![CDATA[<p>在离开学校后，工位的电脑直接格式化了，想着东西都在github上<br>但是过来还是发现有一些没有及时通过github desktop进行推送更新，所以稍微有了一些出入。</p><p>在新的迷你主机上重新部署博客的步骤：</p><ul><li>首先需要配置基本的环境，这个其实请简单的，直接来到hexo的官网主页，<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a>可以看到，需要的环境是<code>git</code>和<code>node.js</code>这两个工具的安装，其中为了避免出现一下有的没的bug，统一一下node.js的版本为<code>node-v12.11.0-x64</code>.</li><li>然后下一步需要完成的是安装hexo，从网速的角度出发，可以提前设置镜像源：<code>npm config set registry https://registry.npmmirror.com</code>. 选中一个文件夹，在git中输入命令<code>npm install -g hexo-cli</code> 完成hexo的安装与初始化</li><li>最后下载github desktop，把之前myblog的仓库文件直接clone到这一个文件夹，完成。</li></ul><p>现在本地只需要完成文件的更改，然后push到我的仓库去，通过github action可以直接实现github.io仓库的更新，运行了<code>hexo g</code>的指令。</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考公生涯</title>
      <link href="/posts/379382a9.html"/>
      <url>/posts/379382a9.html</url>
      
        <content type="html"><![CDATA[<p>5/19 晚 当看到自己从岗一最终沦为岗二的时候，心情确实是很失落，人生迎来了一次分岔，我也失去了对于在广州生活的未来畅想，还梦想着总体能够正常上下班，还能去打打排球，还能回来学校逛逛，或者说也许还能遇到她，但在那一刻，全部落为空。</p><p>这大半年里，我是能看着自己的成绩在不断地提升了，也确实意识到了考公这个东西并没有想象中那么难，你的对手并不是很强大：</p><ul><li>国考：行测成绩：54.6 申论成绩：63.5 公共科目总成绩：118.1 这一次基本没有怎么学习，纯纯试水，所以成绩一塌糊涂。</li><li>选调：<img src="https://image.haoqin.vip/2024/06/ad0328940c5f704c8c95382f67808311.png" alt=""><br>这一次开始有点信心了，也算作有在正儿八经的复习，虽然每天可能也就学个一两个钟，好歹名次到达个位数了。</li></ul><ul><li>深圳市考：<img src="https://image.haoqin.vip/2024/06/b469ff3306971a59f5b359f779fa93a8.png" alt=""><br>这一次是最让我意外的了，因为我完全没想着能考上的，所以整个人还是相当松弛的，在考前的晚上和当天早上还跟宇寅同志去海边溜达。申论也没写完，gg，没想到最后还能有个第六名的成绩，属实让我没想到，所以确实有点妖魔化对手了</li><li>省考：<img src="https://image.haoqin.vip/2024/06/d39fbb17af32c7349c336d5f946a1a75.png" alt=""><br>这一次总算拿到一个我自己也意料之外的好成绩，行测还是不行，但申论发挥的挺不错的，我感觉在整个小红书里也算得上可以的了。<br>可惜，面试让我成为了别人爽文里的配角，岗四在岗三放弃的条件下递补上来了，然后面试了一个逆天的分数，88分，直接把我翻盘了，笔试多他拿几分完全失去了用处，我得面试个83+才能打倒他。<br>终是没有缘分，只能去深圳做牛马了，以后也不知道会不会继续考，这东西太玄学了点。。。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轨迹规划</title>
      <link href="/posts/38502e36.html"/>
      <url>/posts/38502e36.html</url>
      
        <content type="html"><![CDATA[<p>轨迹规划的分类：</p><ul><li>搜索:  A*等</li><li>采样: RRT等</li><li>插值曲线: 样条曲线，贝塞尔曲线等</li><li>数值优化:  混合整数规划，二次规划等</li><li>其它方法:  智能算法等</li></ul><p>参考浙江大学的高飞团队的划分方法：前端规划（Front End Planning）和后端规划（Back End Planning）：</p><ul><li>前端规划: 找到一条可行路径，离散的路径点，使用A*等算法</li><li>后端规划: 生成连续光滑并满足无人机动力学特性的轨迹，可以使用贝塞尔曲线等方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> UAV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>片单</title>
      <link href="/posts/d79a457e.html"/>
      <url>/posts/d79a457e.html</url>
      
        <content type="html"><![CDATA[<p>突然想记录下看过的各式影视作品，看了一半和只看了解说不算，不完整记录，不论好坏，不论先后（好多好多&gt;&gt;&gt;&gt;&gt;)：</p><h1 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h1><ol><li>强风吹拂</li><li>排球少年</li><li>新世纪福音战士</li><li>钢之炼金术师</li><li>JOJO的奇妙冒险</li><li>全职猎人</li><li>钻石王牌</li><li>进击的巨人</li><li>犬夜叉</li><li>火影忍者</li><li>鬼灭之刃</li><li>命运石之门</li><li>棋魂</li><li>寄生兽</li><li>十二国记</li><li>交响诗篇</li><li>赌博默示录</li><li>夏日重现</li><li>赛博朋克：边缘行者</li><li>未闻花名</li><li>魔法少女小圆</li><li>紫罗兰永恒花园</li><li>只有我不在的街道</li><li>86不存在的战区</li><li>一拳超人</li><li>RE：从零开始的异世界生活</li><li>罪恶王冠</li><li>乒乓</li><li>欢迎来到实力至上主义教室</li><li>Overlord</li><li>致不灭的你</li><li>四月是你的谎言</li></ol><h1 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h1><ol><li>天气之子</li><li>你的名字</li><li>铃芽之旅</li><li>还是觉得你最好</li><li>人生大事</li><li>毒舌律师</li><li>调音师</li><li>看不见的客人</li><li>无名之辈</li><li>看不见的客人</li><li>误杀</li><li>长津湖</li><li>唐人街探案</li><li>少年的你</li><li>罗小黑战记</li><li>哪吒之魔童转世</li><li>哥斯拉</li><li>复仇者联盟</li><li>寻梦环游记</li><li>红海行动</li><li>复仇者联盟</li><li>封神</li><li>孤注一掷</li><li>奥本海默</li></ol><h1 id="内地剧"><a href="#内地剧" class="headerlink" title="内地剧"></a>内地剧</h1><ol><li>最好的我们</li><li>何以笙箫默</li><li>漫长的季节</li><li>开端</li><li>甄嬛传</li><li>知否知否应是绿肥红瘦</li><li>沉默的真相</li><li>仙剑奇侠传</li><li>庆余年</li><li>觉醒年代</li><li>父母爱情</li><li>士兵突击</li><li>步步惊心</li><li>伪装者</li><li>爱情公寓</li><li>小欢喜</li><li>无证之罪</li><li>潜伏</li><li>长安十二时辰</li><li>古剑奇谭</li><li>摩天大楼</li><li>司藤</li><li>你好，旧时光</li></ol><h1 id="韩剧"><a href="#韩剧" class="headerlink" title="韩剧"></a>韩剧</h1><ol><li>我的大叔</li><li>步步惊心丽</li><li>请回答1988</li><li>请回答1997</li><li>孤独又灿烂的鬼神</li><li>黑暗荣耀</li><li>D.P：逃兵追缉令</li><li>鱿鱼游戏</li><li>来自星星的你</li><li>机智医生生活</li><li>信号</li><li>机智监狱生活</li><li>W-两个世界</li><li>爱的迫降</li><li>当你沉睡时</li><li>那年，我们的夏天</li><li>继承者们</li><li>社内相亲</li><li>匹诺曹</li><li>坏妈妈</li><li>王国</li><li>窥探</li><li>安娜</li><li>恶之花</li><li>甜蜜家园</li><li>少年法庭</li><li>秘密森林</li><li>蓝色大海的传说</li><li>虽然是精神病但没关系</li><li>听见你的声音</li><li>顶楼</li><li>三流之路</li><li>他人即地狱</li><li>我是遗物整理师</li><li>没关系，是爱情啊</li><li>都市男女的爱情法则</li><li>治愈者</li><li>五月的青春</li><li>猪猡之王</li><li>主君的太阳</li><li>阳光先生</li><li>今生是第一次</li><li>365：逆转命运的1年</li><li>耀眼</li><li>杀了我治愈我</li><li>步步惊心丽</li><li>棒球大联盟</li><li>天空之城</li><li>火星生活</li><li>鬼客</li><li>末生</li><li>偶然发现的一天</li><li>拥抱太阳的月亮</li><li>特殊失踪专案组：失踪的黑色M</li><li>城市猎人</li><li>衣袖红镶边</li><li>请回答1994</li><li>秘密花园</li><li>宫</li><li>那个男人的记忆法</li><li>国王：永远的君主</li><li>任意依恋</li><li>无人岛</li></ol><h1 id="日剧"><a href="#日剧" class="headerlink" title="日剧"></a>日剧</h1><ol><li>母亲</li><li>重版出来！</li><li>我的事说来话长</li><li>重启人生</li><li>非自然死亡</li><li>胜者即是正义</li><li>3年A班</li><li>我是大哥大</li><li>白色巨塔</li><li>四重奏</li><li>初恋</li><li>半泽直树</li><li>我的恐怖妻子</li><li>弥留之国的爱丽丝</li><li>悠长假期</li><li>人生删除事务所</li><li>东京爱情故事</li><li>17.3关于性</li><li>东京大饭店</li><li>短剧开始啦</li><li>为了N</li><li>龙樱</li><li>仁医</li><li>求婚大作战</li><li>交响情人梦</li><li>一公升的泪</li><li>行骗天下</li><li>假面骑士空我</li><li>假面骑士555</li><li>奈克瑟斯奥特曼</li><li>假面骑士龙骑</li><li>花样男子</li><li>404机动搜查</li></ol><h1 id="港剧"><a href="#港剧" class="headerlink" title="港剧"></a>港剧</h1><ol><li>星空下的仁医</li><li>金石良缘</li><li>封神榜</li><li>神雕侠侣</li><li>鹿鼎记</li><li>天龙八部</li></ol><h1 id="台剧"><a href="#台剧" class="headerlink" title="台剧"></a>台剧</h1><ol><li>想见你</li><li>不良执念清除师</li><li>我们与恶的距离</li><li>俗女养成记</li><li>她和她的她</li></ol><h1 id="其他剧"><a href="#其他剧" class="headerlink" title="其他剧"></a>其他剧</h1>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> record </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排球笔记</title>
      <link href="/posts/243d023b.html"/>
      <url>/posts/243d023b.html</url>
      
        <content type="html"><![CDATA[<h2 id="背传"><a href="#背传" class="headerlink" title="背传"></a>背传</h2><ul><li>场景：队友把球垫飞或者球超过头顶，又高又远</li><li>不要后退跑，眼睛首先不要离开球；盯住球看，迅速转身，跑到球的落点，把手抬高，身体重心下去，蹬腿向上，二十五度的感觉<h2 id="包球"><a href="#包球" class="headerlink" title="包球"></a>包球</h2></li><li>至今还没领悟到</li><li>有看到一个版本，就是接触的球的时候，你的手掌是有向前推的感觉，这样子来完成包球</li><li>在看皓月他们包球的时候，确实有甩鞭的感觉</li><li>我自己目前的一个判断是前面引臂的时候需要放松，快接触到球的时候配合上一个压手腕的动作。<h2 id="上步"><a href="#上步" class="headerlink" title="上步"></a>上步</h2></li><li>不要并步，左脚稍微往前内扣，行程一个制动的效果，同时将身体重心移到大致左脚的位置，让两只脚都能用力向上，而不是有点后倾的感觉</li><li>最后一步的时候，脚被没有完全踩下，而是一个踮脚起跳的动作<h2 id="垫球"><a href="#垫球" class="headerlink" title="垫球"></a>垫球</h2></li><li>手臂外翻，形成一个平面</li><li>击球的瞬间有一个手腕下压的动作</li><li>垫球的时候是有手臂送的，不是用身体送的，手臂是主要力量，身体是辅助力量</li><li>大jie提出我垫球的时候前倾过多，导致球比较冲，这个后期可能要注意。</li><li>家铭：手臂与身体的夹角基本固定住，靠下蹲后腿和身体送出去</li><li>在垫传时，手伸出去，重心往前移动些许，但不要翘屁股让整个身体前倾了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gone</title>
      <link href="/posts/5e263ef6.html"/>
      <url>/posts/5e263ef6.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f272c6c213d17436b017414b6da649b2bb3bbc2d513583650e915855cb634bfa">fec85ccf1090db60060503c7e5cbf16a587c8f75be5519bbca4150d8ffad8dba2e0091daa5bb6b8d673743117bedd7783f099b4620d053af429d8924473f86289e72ecc30e4c22325a02d1671135494fe3e4e9fbdbc041bb3dc3876a566a2572d57cf16b06c4bc2ce21461d6127ffb5e22cbd4e1ecc3a6a9becc0e56d6009222bcc07aeb88b4946411ac1480a47ffb0a389d8ad210892c7fe9e99a45d5386116a4652248f591de3a3bbb9318d910da93dc7113e1b22ccf8fad7c8960962d4cadef857ca82ffb50cc45c723e51ec22e256daccac5c034e0e1ab4297cc4d332c73ae2f9055c177bf4df06a36d48db5e57261be754eb05f980739d4590147e381c1e102d1dba65817da50add1119bfc22bd0637e429970ef8af1f3d72771bca0e25d4bdc6b98422918cbb0fdfafb7d049e90621c8a51083f8172191f59d94839502b159e72a79638c49d66df30a59dddaf41a1bf164c399d225d4f133c3a3c9a75371a4503e614ab8d7656379fb9f4fdbb814e5f2c66f59965f157d0b32a447348c85f17c5321c28e45aed38f5bb2f6e7480bb98d5748cbc6235479f1863081c6d635da09046c5c0a18715ac15b3fec27e09ea5b04a38be0188248dfe6e9395783e54d24c3c65cc9eff76e9a04ecc0917efd51d6fef64ede652e16d0fba7b7c4171c3aa3863304f5e74559aaae83226e37f09b2e924a11ae5ad25a66209cc436bc18d6c0eb2a3d1e2c0d747fa5376d9db238c0e485dda76edf614daa43b3e158c93da9832d78a87d58fcccd78d5b4a057f65e6156bf95ddebc2e35fb3ceed1efb03c2587e6b39cd95add91fdce255522ef2ddeaa128853de882e0e624a17076fdfda7d805ba0e0fab2727c40ad5e51110c5ddd60db2a99d1050c52c05155ef62b8cd532d1e11cd3706f837b37a657766255166d96aef0f4423d9b8d7141777e75d8895cdb09377bd88cebad275d9e6629a34aa74432fb947fae6ad9cd0897be243329ee1487c52190d47200741fa2a2e44be6c319667abf293681f9173c70f2c950be4d87c209423a87bb0f368d4850a10e252ef896e0a8a7a6fcd3046c7f78fc9c744809f734b4cb2ae05001c4639c052f2dda8d190e3810eaa7e8416bd192ad1799c518bdcc54ea3d96c167997880b8aab725efa6066c806e2759314cb23e04e747bc1695b1381dcc335ff4d0958cd64624006c72a861038e87bab176554979f33f59d9eed29b19d6660d8c9dce9504167e679441945c02324797e8995fc4326cc921b788081173d9c55ce0ebb52616199397eaf6bd676bab70b568d1d971dde5d1b588aa6633c4c41d2012d2fdbc2136de38c55db14852a94fe3542daa22bf36c147531ba29f03e95e4cc33e8fd5e1d119bc3346801342b23c35a0df8dd1b80dcb61b58895e82f48c249b1a9d25876fb56e8cad0fe8a5802755006c8da9de81fb3c0a644796596c8722ea5c90b2edee24cc3fd2f786064a70e4f0957392e7bbe81bab3b7a9e1593adcd3426930a26242ad0b92d2a2ec90aad6a8c7e5adf3377c72d8811b5bbd8a6657b3e8265af3a0ce3f3c5154ad589caa1a0c2c171b31a637087a5d7daa3becff678b8b0d1433c96acbee2ffd219173f6cacacdad6edcb83c2b047f6c1c01e8085d1ecca99f7e305e6c0d1426346369269bcae75822b5db0cb0484e90dd889b0bafb8ef7d13e7a575957cc94e463eb3dc6db6221b7989d1960241844b0b7285e115a2cfc0e0232f1cdbff0c85225c39bfe948fe14dc64e4566ce7810e6036497a3b1865b686ba4202fb0a2e2f26155e489f87511bb14c7551b2a3b9a38c9fcb59a493bed2a98d7e96d5974f1e272b113f3376bed7b07e8ab09066c94b470c9fccbe1584126944977b25a176a1eff20073dace54b72d9c94d676b93c011a80c7fe971cc1476bf714b49bfcb702d8d2a46ba8f787f6396942745547bb6b14185facf76e29189bddd1c15aa291f12ef37846157ad70f66c2a5980f3907ba906761c5b0831d2a3cda82305fec513453d5878f71d3a243aac58c0184d1f6ea0951c2f65ea9d216ea7a266d7f964ec8302fc78dc4f9de05643f27bcd605be15624f703c35d58e44e7d9098489503646da1182dc5383f6a67b1aebfb036314f50a50356de1bda58885dc924caed4736c98b8b2f6097f9a69bf3192c6bd5cc9def941bb1c90a10e8f28e39786bd2364fef32cc0d19c0c048bb6f631ffd54067bbfab8c722bc0b7f84c4e49a738f2e76df40bd5dede6615572f256079d67dff052726a2673607d829ea4e8d4fcca2d5e75a5e207dc20543e60b806a9973cf71e4c6fe021ccdfa704de19ff38a799c7bf2a5d81caa6bbc59ad5e9f4987b438b6809f9dede2990a4698fca45effbae4786035c6db76c1f9b39c8387c725cfe605f72d9a652061b4549d26e2ac41ab96c9b17a5187da68442d14e30aa8c1c6c32cb3a64e582cb9682872d12097ad554bd5d0d09eca5d9bc4892764c3471f077502e1307f8703e41f213075b6596302a37ab47d4ea63aeab4b505e42ee59f51b552e0c664f5bea1baf9e1fba22e63dc14e712d537a60a51c4ca8f82d14443ed743e0f1a1ca6b565cd7a7ca9c486ac3927837f04fc8027d4eb3095a550cfc7529aff97eefdd14857055b8a1a497b732e6e02543b9b7650b9a0f52fac9b7f468bc3dfaef688411867f237ff2495a6ea9e85cf2684fe86bfa287db16ad4867627f3af607d5b1157b6f3cbe68dd36468a4bef7fba07e538b8b5fb5a989bc9e1697553c90beb9af56b8dece970166f969ff211b77fea1722a48e25bf3759e678a606565d3327e0422ba0fd7db63763ab051f088eeec3f92970dafa16488f73d0a1b32c05f445fed1ff6c024cb161287850dae2de8884de58446b796bf2bf8216640c1cb6889b3b05997cd8bf00aaba917f3a692722bbf11465afaf9f9543ed5cf4ed6d4e291c8cdd3f2bb5bbb5a69442ccb088e62eada687f7bcce2c04f1b39daa459bb4a7fcfc6bec8b9d8b204f407af2672946fec5af1c91870cea430b29198ac192ac2272cd32a9f05035a86c34a98e65289305baad40f6ecab8f904d5a4ff91242cab0833e11c01e9e97c5106b6938583c0c70752371a1fece93c07237f58b522dec703bc947fccc78c3f71e1de288ee9421dd28350baea2e163d8a42bca828c969abe087d7333442dedde7bf1e6a1b85781b403d236c28764f9e439b47546a75a3ea8814d1643d9d13c14b6dd985c252124c61957ed8bf3b312be88dfe1040af154c868db3af196ef48a476f228010f652743e0fa5c097587837ac8a79186925869e69a8d61e307bd8a1a91dde9bbd3ba9c370d4521efff3f731ce17e5f39d0c63de70bc7c19284016133728a20fb6590669517c22a6408b6ac8368d6077bb36b4e12d9c0063f34f0ecd11eaf3b4a50927c6f7e882addc3518ab50d51c07394d541ab48989aeb974ce9a381e4ad27915f3917939368998aaabee01b9ebb1a77920664f15fafb9d5fa94e857b2919fff5c90850c244c2e3dcb3d865822fa2541654e0aed23e9ece5d3c84bb8f02a7e4d8470e131a9efd8e78d8ed9b28892abd916c4ef529ca81c00f1e92ca37e276db795167bfc556ef7cd0a0c59e95ae6d6ff0203979157b6924084fe366f08af758fe0e96877d3f8f67defbd317bb412b797f0a8348e88e65ec64924fbd72397a37650de59f2ef7a0ec8b65debb7e1fab0a2353b17f59a0c883fd50e581f89a97b2956c58d683dfb0648df47840018266eaf0c55a3d1a5d37d29911eb13f16e9bdf96b1d1ddca703f7ed01a9e93c35d7e97ec43f67c8f6216f427ae160874cb0b3dd20dcca61bac0e3d36f375c2832b85e21d55c22f2f5652a6cef25dbf94bf4e795e1e5b3fa8545c5f2b2ef575edc7fb8da31e225d95dcf892e9fe7a42eb437f6ccf90f8d84af894e43b27dfe439c80766c3b2a4925bf4d9535285915571b2e411fa1f56762c72cb799d430229938dbbf927dcd0893c15ebb9ee7bf52193585c185a87da594575b345d4e1c77c95df11cc64639f05b1ea5376136fdb99aab17d19c094e2d07ff797dd38fbe15c95132a45097d8e555ba03b7a2eed9dd046c340ebfa792e271201bb11258dd09d035578d08134e3f51793ae02345b21ca12d1fc5c5b099fbfcd429e4fbe9a4bb9f2a3490db7daea3ba11d20bbeba9834941cd647bfe46324b47175c96d1c787ecd88aa2bc8e3f0f456ec61c3dee4eaa20c3449244190957147ec0436706cfb6d7ab7dfa32b9979aaa5cba9ebf8b8a4b2f7c9ad48cf1ddd3ae4d41b0dd735187160b093e581ea59d638eef350accdeea9b47de37e19fb199a597859db6db3cb47b8436a5c84ccde49c6b6d0398588b374d6bfaf25e1f29c2ade0f7782975f092eebc7afee553806ca8d9fbf680b69215bb9361e48c82692d39b9c4ebb0ea90b789e7e3b5d92a694b6de5e884c50f7cb059c40d4ecaa7bf36acd201b5314f7f3f60a62f6fe2c2a6f2e49d2f2457d2158b738227ad0fe40533299b347145e357c7802480c6496890c8ee9a8eeeee8fb93661b682b8f2b3039d28aefa4fa0719d4efeb007d11f44986c48ee669a533a7b99e2d18e5155ddffcc4be777d96bba122b10efdd30c12e44939c693ed9325a228da443f26c28f3a43c9ee39142bb4b2d086e578a8222e1476fc47c360baefe6d59611f2e7cb43e1d8418f20f72e0b815c736481c889cd8f09c193d2db0d0f7330b61b35eb7b87276d9db6a664c2b1b307fa5f746861f830c28df90fc9859fc84c946f0e1d5cb27fd8072df68f3aad1e80913c5a758249e856cc529edc3167740dc43ac4eae49a789a68a34b1d610faf89c5acde7157f0e39b4c5eb5dc31c8a2dd89bb07349b3254e039103ceb9e261b5c036d0b5640b30c030cf76c74c9c9a258873b2f9cd36c4283bdc72fd58e6bc263acadccde2e241714db89855030444909be67ee31572818d98bfcc901521325209ac13dcdfebf3fc083c34d88d3158dc68429e54bd0e9958d879162a7bc879313290aba7dc1ecb5a9515751a7c03fb8a0df4865c59b65763ef0f802641dad653cf91dfa130d0e43a01a2b1ff15f25f6c66d6e4b1c075b7c2f75e79520294d11e93466750173f905a824eca3e469e670bc7619de511012b435f0271be3cc09275eaba4768ba9a373aefa0235d85513d98ec4fecd8363ff54eab6881a6d323f933577329cb998ad71400a916b3aee2fbb23c1de9735e54fe8240ffeeb4a43e75726f32d59849d4ccda550100e5b879f739eeae6d4ef64f3bee7934e416ec1a9c4cc9b667267b08444da4a4bc4c6822e830014e6dc5a67778052136fcd9ca914b57cfc4f64b7a8b2b0d25eb18130e562a6c2ec786b52b6ee99e3c64e112221c99704b8c726d5568032024918e9d2ceda6072c8eed0f5f44d541cc85ebeb3a8b7d4c1e8aafc1e04047ce6790e1c082e5a92ab923f3baada89eb7cfde190156fddb05aaa682815ed5a2879f66e00a8dc4277002cbddd3caa6c204c942f9471ebe320e3724c64db2079d6bf9cc32a32c9db3b8b0a885ce65f8130f184d454625d8e845bbfa2cb9c613c3674df9ac0018e25c379ca85546a41494864f3693ad2d51f5231124ae6f581d16ec9e75f73b3b975975a5dfbfc7dd8bf83117027bb40271eeeefdf1f1d49860103d11828dfbd019ea8971d12d989676a49a0a0dc0c5e2ec07509b0e7d0fe19a1f84d69b1f892a34931b99e71130f3458d76fb3df3877faed9948fd92514f9b989341dd0d2a76447251af0af0afc0bbff2f10244d4417f7660540a76816a4084186693c8d7c7c825ad932ed3fa2f8792a247f42d90d11348455d848b6b4fd85af400106f4cb6f2ce9c228d3d8eb534d4d7490180d6718fbc30cad3ca5b2b9169f2dd49262776a15d349df2b98dc092b9f0ac8de1cb587486dc99816f393ab2ee9bed5b26217ebe67a01171bd83a117e24ff8eb2357b3a08d6b1cf078c91690c29def8ef0718e18dd58792bcfc3c6e092d2e0dd0b63ed727bf5d7fb8790835bf1e0abb0ea10b4bb007e2e725bb1f32771fb0284e8c2485d69a6fa74adc8596351ab30b6eb5ac4cc16f538491091b0d9164f9453fdb3b06010e8d5f442eca865ce26599d327e5d6ded0a46c3411d64f012b941684ee562c6854adc618be10eeb400e95d8684f198fe9be86266524db4593e08e073956b74464a256a1c0068d97543579ed9bfe4537ed4ac57e2a94e521a87e9c8fa94f9223546cda84d605ed44ea343c32a6fffd645179f1c92b947385e4af8b99b7ce177a2557b2d3d268e61753a59eff7ea21271e880d09a12ad2b6b4e8637d6e8fafc6bcf93ffc9f56129532aef53a4d5c04f0bafa6780d42a211ae16e65f3f320bba26bb865f5e26f8e356d64d8695ff2bd699bcb5e8b6afd5f6f2c09c9897c0b0eb49261b7d277df4daef40942343940e8a20d0e69c619be1da2040b42d2246b5312e095ad1a08dcc7c303edddbbeb627817838322921e692d73a961815e70b910db4fc68ac61e0791636ecb4ce6b5e0d1cae19bb631fa92e3ddb25435df2bc3629342efecee02daa1ecc41c9b37ff0ed0279326095591b756326eb2c01d087a27d8992c17ab2eca8b1a9ed10e9c782fef50a4de4709948ab07fab56d29d2d5ee6793a4588e9086855564f3f35156f459e71008a8be4240afb85c10c53841dd9156ee1afb9dc78eee3075df3fea21a04ddf84d86b3e0cbacc76c1d09955449818e0ec79cd5c6826987b11ae2620ab7164eaa4027f1bc471bc24ddcfc0795cd9573dbca8240bf5070773b40b093918f224621a044e3ea417721b940af9f8a336349c5d183e703d6a7ef1aa780ce45e707a3ff7a42e350422b0bf86d2320dd32cc11f86b62df9ec8202f58fe263225074f58fc0c92a8791e0774658ed66aa2f0ca81315ed6d518c65b90bdf94ee58cb7dfbaa017221a97b979479f3e044472ade0c0a2143c02f97382bc4cf8895dd29c82f027a9c25a319f45c4c8b7ca9bb707e7f303cb2533ad7e2228a3d1217ae0bf7507f1d8edbec3102ddc900921e87ef36a0cc50f56b3eb2bcb50f600add391e7532ba41eda66f2ff99e5894256e57deada3056fb05de236518ee4b082549f084c90f649728032ecb4ac2ce85feba60d295d6e18e7604c046f565a9ce9aeff6b017eb9bb37023ef03648f04d63bf6f9cddb885513127b5fd7726d6a2945ada7c7b90e5b4a1fcdef33f8080364d648049a4cd02525b03dcb5e389df841f9d9c4c646638d4bbed02c4fed354e835decf8e04176b3a288c1a10fa3b47ec47f7f56795209f688bd82536a854a4ccb9e89f594f3c1979436d78555ffe977e165a5056889f876bae67dddfa054ab289de728bd515aa86c56fc8f968daf272713d0919d911277447775dd873f80083ccdb0838cec1d94c9cc25e68a75698b0403dece4f7186d8ec6d0f8a6f04ee81642f450aeeb8b0830a2f95872c552cec5a6c32801c8ad98427ec4bc7aa9da54a9cff9c176de378ce54c51302226712de804817ea6415c5f448769164c95a4cb26c0c7fcef023adcd9fa1e11822ef9309fec68a25a8b413f4b5681e6fe3e2df59cae2c96d902ba21777fa9787f80992d7e69d045d3bffbf629248a9d849deded9f4f2d6dee86150317fb1000e55d3b0f94bc2ec857d422e4938ef6e0de06b830ef722c115287569549eb91076cdb13918bc5f658efd4e37acd78533532b4edd69ea013c5b9fbe9035ef4997b298a8d916a37bc7303e3d9076e4d8bc48587e8fd422bc85fdbe586627a1a428177d23a9d3b3a22cead27e9348af76aa70bc3b5fdc9c57ca2cf565ad2d58d87e265f7aa6940c98987f6a8d07664da2a33c2ee50217d338d7b6c9d235a01ce1b81787d9bf9b991d2983cb4b7a5527d5194b72f420344f6a59ba814676f44d1991c862c6a180ec8c4b93dfe4257b131566cfac09bdc3057296452373b661349b8e5ba10ab78e2b6581d084c0731d0a3798b0a6dd5051f85d1e075a6557d361be4d278a7d5242329dade4657414c5339cdb0a6ce11d75df23c0bc28111276e8341388f28066ad0af2415403a07b4c3b64d051d9de887f4183529918b4162579977b1a8480bedab733652a722cacb4e1b82ba893ba35de08ba1fd8e0ce2a81240b8f30cf36e15ad9e92f5663687c0559c1a6acd6b1454af019a825f05b8a3e31f445da36652f1c03b6ea708d94762b08830272a147ba20531b6881005a248de0ef41e997988e45c78d6194a7803d05ab4f47b0a92ea0aef4b954711ecc3ab4a350eb44e2a07487e64bd28cbc85cf4439283404af47c103e9aa1b4c554578fa94e6db764e18fa2850f39841dab30203120ac8870d620ff956cf456c64a0d42c7ee9f447dd674d3500b3e47969411d774c54d981910bae9624226f5811d33d5cd919fd28aea6261a929e0c2ac963596119560b83c043ef101b200dc1050681b5c399aa50690e2bb5f496703447775483df52f15d6a6303925dcd6420a8a8d9025787be3a26ced688312b0e62a8ddeaf38fb92f044b9100c33679cba399595d79e4ead87c187c3dbbf2020505a7da5d555b1329a486d0e065277038bf5c7fd78a25b5aee5439a6a6602b41272a34eb9ffbbd62a92dc80ec50571e691d69e81bb7d1c433dfab99d9b482f5f73ccc324c2583dbf8cfadd98266a443d4bcf5fca84f5f34c21849d9b71630ab319842d777930e97ff9fc477901f24dcb5032df202a8c8737e7ac7debfde421d4e9466b2bfc006c964e2b380d51a0fe9131494dd5e2d4a6e7be30e34704651088f754bd737f2aeeda6a560be42e15287117da60d6537358c9b0c02f3b2ec08907de8ab9a42a132beece99a694f224e8e3b1ba6d2017c766d216fa53e7256f15434cd519f1ac857d4e4de84ca7c1ac9aea279335dffbb53cce73272b8d7d068ef6e9e257cdfda23b6ca895861c5c858e745a3ff946de44a31335c48db8ed9aaf0ca1d9540c53a8496619540363254876353ea62b79a98be7ea01bc2ab5894c12595f27e720ca804a4c8443d1bc7dde1d94c3589a2703c07958a721a23070f9db6bef5fe68a19d96f8e706fe0c18c58a8fddfa7cbcc3854f3a41bcc35f57ac43971e5c320886cb85ac5149b38a741ec45c2b2f7ec18393a4ed16e35add20e2b983ffc45cf0161dea1a21137c1468449aa5d3daf6da29e9b84b82b560642973fa2436354674e9d508e95a8253c0b66ed002c8edb99c655bab94ecd5ac1de1dd8df5ec04eae1b5fb2a74c3e3e3206a88c5fb8fd7ce6173e6e0263f9cf3b8cd33354181088030a90f02134a7ff7add69147c9e77fba4ef05587a02ffbccea805e0d50a67f3fcf47e6e078caf06c556e8b3207a68d7ce17213d04c82b8cc3d63730f9156da39247182c43e6bac36621e47ca8a9b193082f46262acadd9686d2bd04a2b1253ce709fad65808d05fc5de02ea049dffcbed961bf10dc35e7623b283c0979fc86c81926e2c3e1add10a00584d0f3cfdc8b08c1fe54dab413a02b1db721592af318f27981d51ca02153bff9060c1e267dab68f1f1fad901bea71f4a439b3d0dcef894807aefc5c62cc2454cc328790d6e6b1b70c287b33a52797e525397abff31a80cb0ac1ca633f25754b481f339c8f16d170b885292d6e5ece7dc9fc3e3d65077aff546aae75c8f2ac09771c52eac14d73a7f5383f7d58e5108fce6a5558f0dad907e148209192dea5a0e0496c4114758cc31c95238e9bcc2f7cc15b4761400ee69f5d02d8dcfe742e1f64258f6c57094854df7d744922c4abd8e48cc5ae3ad474ada25d06ea52ed5531728da20340d5b9adf1ff0f517c6a98bbd12f06639638ee19f6bb6461d80147a46145f4018efd867c8ed970251f1add74f0a040939758711e81bc41dbbb88f22ef004c341ab7426a6b051606d6c26b2ce5eb539a14b502415722fff28ef1bf285c84260e2bb77bc9f184d756853e3cf2aa93734b6b367951a73e04dfbb30dd1028e75297062b3c7a6cc4c5c6818e93b6b61d3eeaed3480cf02940b7a65befbaa5cb25a46b500e0f2aa63db44ad808ba66c33f0662ce7ff6b9621048123ac5a38833ef34059b7ff0010502fa84a7e37aa6a053042801102e28a7c29917eb2bafa744c6fa72e9a3dd1001a10723d268e4456376c8361468684be12cb1848cacd1939ead6869b54afe0120fda6f09d6604d65177daeebb829e3cc88cf43fb0bd3e415f4e6a1457e4e67b88df0dda3e56a43182599c43587e09cc01305a9276a005c195f96dff74681c5e97e5dd10dad62811c93f8dc5d4ed6cfad40389d6b039eaed133d826174577e43a55344a1d7f49bd27478600744743858742018071f54f357e0052c8f77e50188440f8b1c10a02535087335b717040418c9ef9977ffe3cd20e56cef09ddfbcce0953aee5e60115554d7a4f340bbfc89eb61f47a36bed3e3dc88ce3c719005e65821f5f221fe83346535b78fd8a0c01f3410478dda3c5f32e6051588075058bcb7904542a23e69cb789640c0940c5eab63297ccb05c3ad73dce8cc5ca92ce3f393bea077286ed7c46e5b3646bc4639249ce37ed09e7e67782724de26e3de12405e18383d537547ac97343a423a09718b12383fda821a9bd7004ff88ef80e775f17d390eb4d6adbb80707a4a7282a767e5c822d1ae9b5afe1a528493822d7f9196da2219589f8dfd3030aa5772782ea8ed027efdf66e881238f0d560ffafb77a73f8167436af1de19e835fba8b9c8d56d47c676a2c3a71209988099d574228795f818e614e21adbcc7de42d3cb8cdd8174548a731a09007a38bfe8ae2d97d2079db3542edada7d4a013d95cb5d7f22aeccaf8e4d75cb47cecf415b7e9a8e7769787a78f147d45e3bb471f71576359cf6bf5bab5cdd44df9c84b54f192bd161e7acf72713691b35f1e36c614e4a2783c0ac4ff97c2a329b7f1cc0f1585b6b733624656682ed91e0e210db461495a9b1b11679628b597be51da48eab6afb0fc28b498e807dd16669e9dde6c7eef6834b194fb2ad7a1f17c7ff992cb2df4c12f919a24d80a4edc45fb49b0db2ea30554045df898bcebd332e4305bee924fafcda9c301cda58a1a95f5d7188209379ff67d3dcc5764089b202757806004c2a71e8c04f6a3e5b8ec179869f29f9accccd5d49d53f942a9e8413f6e84b2fae8b2075064183d962614f924ef1e2615db5401d4008380aedd7b6549d88f3401eb2435864cf092cae9fe1637600c6e218630bf4d0b58dd8db35062743125890b34c0caaad29363591c7a77b923190a58f0a0c84af781a68d2161a4632644fb7623030cce6d1c3e338dbcc52aefc2e31fcb258f2812d7818f3bc9f4854e9f76dbdc4799a981554d95565c8eb8b0253dbea0b5d6ea8102866ebd7597f0f89df436e2d5b5631f8789ceb4efb0af93f0987f2a7f2ae11d1099cbf927e7aafaf30ef91064bdf1933b46eaf7274dced2092e2499e50f788bf1fc6c8226e55c343c57d306a0e3cc5b8daf37ce4b2e0baff8d76d742f6bedbe794927ec2cf62332b1894e1c6a371d131c9f115905f09005ad1219ae97d3285309ae684b5e7722b6550d5b37b5bdc0f233ece1e6fc3ec635792154a6557e7c6acf218ab31e8abe07e215ef81b3f10e08ef4c95a023a7f3535faa648d7ec6e2b8ce564efab2e6b669bc846375c5f56b5c696b8968fcc0c455943ff4fa089a7b17c2ab85c0b55534ee0527c90005cb34d39fe268e99ec4f3e931124fb96e0b3fd880ce58a6ad7556bfe332a20f78516d2a2149882d2f24703a1418bb6b42e0f4f2540988b2be2bc6b22d457eb36586a3c3f23dc41f9b042beffd74ea32edf7bddf4229245eb793dff16757e10b9d580e0cd43f5fdafaf993852d85b050d0186144bd75479f0294b9655f870c6334a18e70252b46c800223988fa1625da133b0bab99024f2b589f95a6fc71d3ce96ca8473dc3cd6b7d9bda9c72f5c206a117d0b200844fe294b4e76acee805fd9f12fa3b62ed9435aca0533b4ecd528295c956bf00bdc459354483d8396d6bf87901aa6542dc8d26ab8f9f014c4764c68a92dd85380eaaac7bd47e11fab6e0345ffd646e723c5d2a2c664d03ada32ce65d812a5ac0b1ac8ca310c79da56ed904a9c2240d219fcf34387363848bf81eec46e18847b58bb237ec39f9e549209ec67b0cd7de6f346e820ff582859fc7634efb8c7fd426fe25b58c53afa6f159005a8094fd72d12745bc1b6c45a47873a494d066de1eef8f6e4e2145533ff832edb687ffe428d25a5d1f6e149719027c677d2ba52190cdb409d70326f0a77d90696db61f17df58827a4fdd83ed499ce405d2dfa43ee9bb2098cde9d8abd339b66a33402fb775b11027c5c03892e04d42f7c4c10d045f0d5a690e90f3e8148d6290f4c068b5cf37b7e77b3c26c2d9cca5faf351f706ab4627b5045f7d79d8812cafc8dbab31da7e4dcbe4efc2309116b1be101c4540967964fb2950cc25b5357d7e0b40b592bb2b4afbdaf723cd424d62aaecda0bb08e2aa5b889c37096eb236f76ece24af75cd0af4017442a8a489d35787b8d699c2b2fe7f041b7c093d81d971695551a5a0b56bbd03ae530b8376d9cc42cd39dd517558ee799be97654addd61e8ebb9b6ce786eb0a33499659632a9103086f5894c27dc067b3963c02886072ce253bcdfb6ae527516214e3edef2c222e343f7bfea4a94060069c4d5bb191e607e750c817fa8b94dc0fa50f2b3cc9842a028b2f8ade9f62d7a718697b43f6fab69c14840cab99a70909316876d4f42c13244d6a6d49b94d84093d249e20c777e207a2c53db52cfaf1aa5482a0eba1323f13d43726732661e425e59a0976b576414211040e15a7f98c541fce31ec00d7f8d0ff795fb6e31792fe639c65f641361e572787657154969c0e01c5c50de1d3bfafa128b8ae02ebb06d6a024439fdf3617f6f293b37fb4551d19646798371993dffe4a133602fbce86663a25e018e2832e097ec3a32649f0d8cf1c72ec7e8c6d2328c521ef43666cb0581094a0316e3e59e68eea538180e13d7b3242a0296923333576ac534e77fcca2b74b597860f18b34c06043a25fef9a7f47bb9d4470977adb4a903cda6eab6098cb4a6cc38bba8906e976012a818188faf71af33b98736b75cdff61250235af8ce8e6fd4d482073ffe741b0685a2ea1ae6a20dd6e6ba0001d9b8bff125563c6ae5bf8034072c25f9d862e2201963a8bf633d1bfb1d81ff4549bea851266c5af4f8d81aa97894c6c3cb64813db077d41e8d2c5c47487e2f435317a7ce4c3cceee72f4be545f1e72ce495db0dfd6bcbe38cbfe28f1bae99677ff92e37636bfc0f49fa4619c3c1d7433e5a81e444150708dcdc3ff46e5c90b7413cb61f4e8d7b31200d799f66498f2fbb3f62197c72b5d5aec2488445f0f2252f92fc4d7e3aef772d58616bec1c85026af28dde6c676d6f12bae711df0d8fccd0493e3780eb13424420ca67c812eaf54348955a3947afa11cad0a0380606cacda6c106c6ed808653872ea3e1a85509ca89ac9fde0390a968f7ff670f5bf4411188408758a769e9056dece9b9386df82c8045fd964c01644298348ea8e35603fa809347e186782c1549874a23a18ada09eef22c1b5618da70f3b1368b9847f77363bc7bf12273bf04a1d9b31a8a7590e8b8eea3ebcf7f8c8c2ccb2a24db60e58491dc341d1f62a6018e768f7fc78b20328ed4417c2a89f04178041304c611c60d73dbc14291c622af732b2f8fcaf439ba9c7fd8148ee949e4b8683af4048a68b22be7aa7061516664dfc45b64017be0cf096e026def03669e77c2bb002b166e234198116aa0f46f72d0c6266c1da7bf189dc877ab5219072c32bd30b2e0ead7757bf18dcc93df6c9ee235436c72b36e7d109ae531eedee0fd5945f7915450d56de7fd0677440c2f7fa1cc5b85c6a83a629b0ee05e118e8bbeea0e26ec873d39578ae81246f4333282fc1315c5b421f8dda0237190092be4d10b4ae41ef83162e9af0cdd8bd7f84aeb1b339d6ce8c5e91a4cb4ea1aa75ac4d92a9c0e5c21598276c0de6b99aa81e68cf1f2599523a4684ca9da25fb0acca0bb4f8fb0b562ad2e9091bec7a94429ca41ba3a3e06aa92ead3df1c6673dc9933395ea0b1ff87f0aeb2f4448ea69ca2e6cd39456133d0f4b31a6f37626e2a8adb390fb82fd3e7ec5653545e5b8a2687475b972a79657aa7c9678eb0d76737c41d311b4b2580de0fae75c586abd2953056292f1f0a9b5638bdb322af3b2e788b876cbf95989b090fac6a4f4bc40fc3e71555efafcb2edbd15bb2d253d85af0b62270d2b8c727af0307acac70ffaa5cb95e2829207d17427b1300ac3debf9a64fed58ca3e8ebb6873c2561aa15e3cb2a3b69c9e943f4c811a5e777c96a5c61d757a1425685842fccce84d5362b6f68a6e217241c8c5560f6bcaf815c7cd03fff31e7f8424b55dc47df2a9efc8136189d6ba19671e3fe8fd354f3119444135f5b4aa9ece08e99b0ecd63b6595e2d0752695f9203248b8fcd0ec1c90453dbdfa02bff1177cb70f33b3ed74e9220f3d4dfc9f2a2c6f0cd315b118b6ad43c0d83f46595e66bb1de35be2d47d165f4b244f296b067d033e9634e4ccce4a53789bfa90117c75ef601220d32b77b78adb072a328f27c803fa61d9974715f81abb9dd7699cfaf90c643faebb62a75df714128e61f370568b273451d01da1ae370b30783cf958a10bb6276a61d184c1dead8e05d2fb2e35bb7941ae27f242f3d8de2aee9668b0882390671e4f58277e204c0a8570e9e423a9b47a10bf6f5e613bef46febe29f02b8690e995c7847eab72f86fbc90e4cf2407b7d423ef3ab4c832093f32ccb46cc378acec4d40ecdfaf48038ca7c25c0a4222c406ec6475bc51856e73753ba8ea1d4ae07ad6e66bbfdd80b8e7e4ba78f6700c03b81965eb5059a08a06a594536de1ba42fdc11ae7b6c119436519ccc952bb3d9dfb9891196e06257094093eb5be815c21f9dc1a2e3237f2e44595c0c60a423929521f02370411bdcc762f01a1227014b8c146a3d9aaec70d2d0592eac85d50831b6e454d4aa255ed99751444a5fdc26ca19688b3d27d6be775ff5eb1c85926df3a57631f98317acd1bc0501247d26deae8eaaaf990f6e2c0bd7d9a5d2ed6298e9f972749656600dee646f53b347f5557a5e6093e20758d5f13503d40e3bdd7ce8e345ec7c6fe2bc14d1842809d77c5d3b78fcf8d1e59dae5133a3764b8a3c26a20277182fe99312ba28caa7cd01c86ec06bee5e99e560b482eb5912a9e794d7ac65eb631b1585b4f8368d79d2d5dfb4ace583af9e89288c4d1822045984ae183e0b0de5cf27bba157826d81f6fd6ca30e3f5aa945bf8e526c2dd9e30662d13c4455b2ce799ef6441169a5b9a3c480021c14ef2d10fc12f6b5798d806851194547556f0987827855fa88ffb223620b2dcadb21fdaf65ea7cf842b1e6e07ba94b9bb288afc5f20f95f58dac0bfac750267185acf800d01ad0e50d8bfde61651907a1707d7c1a41f6d6271fe1f4570082fd07e3411a98a3bab59942847c978b592550fa1db80266062b5a29daafa8112eccdebf395faa7475974d7b3a2c016eb93c26e3f3d3f8b8bcef41eb526686072b135ce9e995f3eb08898c3cc4670f8c355a7537296a63a330eef8e8be366907136c6d80945eab049636bfe209f55c16b771eaf7a4f9a7444d04602eacf2e6e93c9cb0f366d373629fea37eba32cd93707b85a78088c31eda531b16aba34619684ea74aac35d228e006b895021f52af054dcf8fdfe72277e7438691377fe7d6d4e4bc5c703b8946e6c69182abcc935eeb861446f0d37b2ae616ff73c02c62a1d4f28c5ccae59b53f5633762e9307cfc432fa192620f76449d9933bc9af45d5b17ace7d55b6eefc8eb7d432667d035511ca01d70de631b8be820216ddaf76c37c322f73a751ce00b81f50995cfb528b5fa7b042075e095108a55b165cac6f5cc3ee8a8a419d3dcad1690ae9a74563b84623cf9efea5de851aa88c527e9be01c026a7833ab2bf380fd0e4b348bdd2f934527f7cc19aa960ba2e5513c12909168ce1ef302d706bc6e1a7f2dd15d885591d66c9629eaa23d95929bb176c6277f3e2c13a25e534ea59c79a751d9e5a20d31d7d06759ef8543f6065f3201be4129124127843ec5fc23e12f12711bbccb5cf4f036f6f3903b58ad0d6079126e5ea7daeb25705713e35243e6b7d93f1cffe244aabaa4f6c5e0c0a7b8db64d1a9bcc7e444534deab53a243e6ec16dcff359d2eecef45f8dc132e086a2682c71470b882785fab6aca0339a784212e7f6b81de5bb7b279608f500fa3674e7e45c0777680c8c097f4199e70d50e024dbe437af33eda7e650cebee74313ef58ac71cbb3dd8cb384acf0aebf7fdd33ff183034499d0b78d7aab24ca6847a2fd0815fda9a7550711f6966e4485f54a75c56a7481928f23c04e0a090e25236b8f707c93de1490aa00030a06658de3fa55f5b91a3b556ea993190f2c39476180093d2fc52865ab01ec65405625b23da413bac75c81aa3352c36fde0398cc1fe4f5882e4981c6f22efa57217189d876a274a616fae5343e6cd4a927193eb7169fd25c0d9a9b12bb7b974e94ed67ff15f2b70c95aa49cc20fd31ba4e4293ebbc6e4737deb49cae0254b6aad36f1a9565d4897949312ac5af99c304434f15fd7279d0520db74c3d5cb60e21f9475c0dda399ab8ce92fee21cc67310a899020b7a8474989767d6f21abc0e817a2642eca8738c65a7f6a90a43079da0ef18a81fbe8996f8ed9430bb41e7b2edb411d7895a3473df18aa2313a21974b4cb26a8c5a8ba044f500633d4e90b72a129f8cb40b0e169bf83ee9ee94c0da663bf38741342d367a6e91e25a7e45f1b5c0136526f795e2b845cf3d3c2740f69f50c7c2e6d76a66a5e55be4d228f9deb20e20779f34cd6706f37a1f84893351f19e7e3b1afaef7088e9cbc8eca8f6b278327096c65141b3dc9ed324a9e3383bdddb949aca3f2304f45e42daae90803f13cffb32936cac9f5d292113dc35dbdde0980a68212303b2f84faff9c86b8909cb7f7911b086a2e286589d33d02a90ccbcec5b2f1d56307de033bc1ad7229449d47fe272817a5bae803e7c2cb7a1674ab508529f4cc84e6def395354ba0a6ac4c1bc174db0a9378476969c26fd252ad28170bc1c27e1ee942e581c81e338631b3dbfb4470c3c5e882445ed0ce0fa710f0c8904735d566463570ca1c543f4c707585570c8a1f480fee749170048f014f94015a6cba2ca825a259e2a6e5af9bd62e9a3407b259c471e281da03582607fe7e53c4870e04208d96636324653bdfc53b0ca9bdd8c2e90ad9a8dbe80fc29612b5fc654d5813bdb4fb6ae4e0f91fe62eda3a94d0c6b481fe5036c5742bfe945cb425fe2f0361e260b951cad82ceeb8ac480fb32de95374c9f4ea5bc5eea9ccce5c16e51c70de07398015ec892e8f473b7021f210b129f9aaa6868d9bfff66a24745d6b65d8d44db7a024bb3e16f0440702f1f248e6b63bf6ccb3f5927620052b3fe59cc6afbdd73f4287dea60823aac49b3de6b30abdb5d3c6a7d073f84f1ceefdba913a77523c92e90dd60b95bf6ac03aad674f762bc5c0ae798a61b9e659b7e8e5b15fcb0f5244fdc97c0d4abdeb241e162a14a062655c19aa13c83d5a9d93160710694790c9d6c3e3ce0740d96e109d425a50bb07a2289b9a5b166f6fb588a9264b39ecc9f99034b0434837952e0e59e710034e7e360a0dc3fb056f628f61668d28cdb2f74e018cb5622e0880f8aced0e60505ba527318aa39bf9fe86bb41073201aba66f339977a6d1e9a1a91167503dacc16cd2a727370ea41925da4081e28e9f17cb33cb5c4469dbe625ef9ae872fc38c873d62ad734bd8a1670a95cd99f764ff3c19aa4afcf28efe640025b2e2565d4d958e84dbb46e29f5aa1b13a772c1a700fbd3f33f1dd68e7028a2200d851b82c38a1db9d64890dde947f2c5a5eb19170085eeb500fd2d64535e7673d88f0d7d6255d9b2046dbf5ce425e5dceb1097e5ca35429d38cbc8ce18abf40cfd43ee623a1301a654733a65d0b68d375bfdba2407e58a5c2a33569da872382e33296dcf266eecfdfb608f1ff926cf64524bd4c91931571824893af66d4963b9aad040c87b5fa8fc1897e35cc6346e0d20e1d5f93e64a0e6863904cc37b4d3d3afb2077d4d37a9f64766d89a572dafaf1acb6b8d902cfa5430a623d6a9e5e33f60efbea73f37b49a02787a88ac86d33ada6753c0ff34a540fa47c309551a553db3cec0cbf1a18ae72052e6982537a3174672dff56059f641ebcd52dc2dcd667e9666804bdcaba7db2e6c16d2c5fe2c9367a105f55e06402e6139ca4dd95042ed90602d90074445191e23378bd0fd6ae8363a12017e93ce6339a788f83de326ba022e39029142cac66fa5d835b6bcea5e025c52ccbb95fb3439f86e65f7da2441744242754a1126d88cccc1f72f77ef7059e66f611d90b99589e177fe426a3be0a1d01b31857a712ad60c9e435ba2bd7e8d246959a61c6e6b2e03d88815c41bdf44c617f9da7227525cdcf9fcb70018aa6cf945c6ed378812f496e4631370bcaf694fd26ed3479475083c4365a1afb958ea715298d2fb340c3db04cc08ffff5d79648760c6a5f86dda9931a12186510ab738f07951384b552f9cf13773cfd94a51fc95544af90ec3b36c18316d7cea7d93c630c9dfe0a10175bd39136fc9442e7bb3ae607e025bd4b9acb66714b83674b92cf9f6499fb19dfaf5278f945275df0ba778f43124843fff435386d23708f39c038f2369fe729b8bfccab90f26aacb15e6922f2f55921f1b3ef1fe14e8762241b29cfdc4b722f9158eacc6343f49dc72771f4eb15cfb522df0029d073e124af64e1716d200f306e4ec5bbceb3b946b7f7484bb58b5786696eabcc28f90c188394e8b9e21863c563c1ebdbd02b48b5dc20b9ddeb3664949a25acdf36419f231cdbfb789ba1c87eafbe02e30069bad26b3faa3e55fc0aacbcb968eee487092aec0b70aa68840576c3a806ff12015c5297ca8cab14a64ace3b956c51a8afea381a4ed84cf6945cb9fcc9f50652ad1d93ab466d5e7ac31bc3c3781cd0b320dde3783d907f5eec31b0d98385f08529615ef153a8d3433bf38c257b1c0fa3b69a5e8eebbe89a1809ac1c58deb83f94cc40df61791b5ee2ed70e20ce47f1d85a9b503c68d8f80ff2f5b36b6cd83f0e84db7d28ab28e52ff89bbe7f26b2647f63051c2ee279c468ac425af833af5f1fc1349a9bc6f1e4df0f340891f257c7476d2e4a959387b18f64840a81ebb402b41ff63a5377a9f48bdb5611c81851871a4243043b000d0818d3b57b42363b9d40b96201300090099926de97ff2bc0dbf4b920eae873ac8fe84b01943d6e592338b09f8ac8ea60c27dd090ad33a9a6eeac02a5d4cacab2ef2195def2abf16fc6ae8e9b0eff2b240b085881a5dbb8245ae946408fca4e99500fb1347fc6a8394629aa1728a15cb8f0291bee828be9c7b31da039991bf439677923b7b599bc80a9aef21ea8044ded192a0de65ead4138e936c29fc454d30bd763b4807e936b6abdbad0e2c081303a104228fc1a4faacad2b785c6e357236f71b84c66e19f2605ae32731d943ee6a77135e11cce9158ce07a4c5c5a3c709278d37ee587aa0d9926beec99a03f6836a4522856b98069edcf9d94942f313c5795540d0181126fa45f690b19ea4b1eb37a1e4ebf7f7175b4bd5ba1fb425bb35ec8968d3c9140880b96c923e6bd7254afa2b7e96350d1292e97cc9148c304bb187ec65a2587bd9ce89d263687864938968326cde1c6b92d2cf8fec59a73a4b0762fd2f07d6bdbfcda1fdd99d25ce08d5bd4c7d08602eae58f1d5bd684c71d565268d04df19829ec3a2a74835516ca3e3edc8d529671316df7cf9069372e4bc3f4913d734a83e37f1910c5e07faefa0cc12741786ceae9936e8a60e5076ededc60831ac30a15aa4149004aa6031a47ca3741a9e7b6465eac50b03d5eb67c16833d23545ef209ed046d6e238ee56bc738d064f8750fd36333b4f37b8fa12dcdd94a0e02d4ce5fae314d1354e0818f424bce71cbe7b0175e06d7c92b1e59f6f77e8b7782bf6fcec0e2f7e8a9465f5e184b7550c6704084d163eaade9255c14bc54377291efaa2a4532f496978ce60a6636292408b85283187c47ff0b483d3ece19a6e85827c4f46f278d0e5dc8f4aaa1b81b5fe3fd92ce9c31e0944471805206f8e30f083ea4f063ac4a8d71be4ccf6990e4f5b1e797dbacafb997ae68f5a3e11f0b2c0cb71b39b0f796af95e18b6de63ee0310657febccc3939fe1e2473c8eda3e2d72f7137530a61d1f6b927c313a6571d7f54b93d1ecb05e0b0d48aba88c124e4b76a46cddf06b27e1c144f5dd42cef4a85d7b7804d044788a7efcb75c0ae4f5a7f49f1d1314efce2be17aca5e6e982c0467a4b227fa916820043e7964b6eb4223a1405370aa97e38bacf2a680d5ede1eabd90337a63acbdd68fb41f6e9ae6b0b4cd1f506b98791cdfdfed711cf2dcf97c0e50619db92a710c5d3c6db27d798064de8e59ad7d26d0c3c776504dd4f8b7c8b32f00a7f757dbc1c6ca6fdcd7a599bf42a8f6c653ee1c3bb3c56ea4b6711caba08648559c069339c2f4d887ecef671b308e639a743f460303ca2cef0c7001ae345f742858d3eecb220b37bacbef9671cec96092b26e3dcda0ac15f1010fb48b423a8059024786ce1c239520fcc0774b1c91bcb5679c8d5b25e91943153477f02264f0e72cf8d298fb7f3118f651a5923b888803c15eff228c11d0e3ddf30d5e332289707dc3ff5c39b0ff04cd3bb66f257510cf710a589df7cfa71bf0b7128172b6653bd344a1e165ad54e2f815275d4f49411a2dc9ce999a073be994bdb93747488d3282ebf34a7f89a49100b23129daa797d3e107b20160202a309d32c58d912a09cc36742e05b45bab6b5b982d211ce9fa00f23dfd1875beb64d70ff48ea1eec6b6ea72977624ff0690c41444db841b760420c9bfbf0026bbb8ec04add2e8f597c41f7493b9e59637916619eeb94d813d1622450a4dd3a3791b07cbbf6dac7edf7f5eb32b4c8ee932aa427f04dba3609377c35b921f56ffa0b544c68df2f5fb04baa3e2b2ef8579e754e78eb1b52c74dc02b35ebefa53ca9058b1fdf25c5065cc6d3e4c25051bf03d74b5323221282e9043e5c1a543331bf9454edefff58275f8ed87f733919ec0c33780ae7130a4f945ddd325ce388edee54e861e77ca05fc0c46e222797cab33e00e23a6f4eade4e88e9a0681f9da6ca132d350f515d1772493bd49d7894efda36a7c21faf7185e5c3441831f2c3529e593fd797f8846e880015c343a9cb31090813555187520260ce68ec494425d180a5a80e80916b88f170ad134b27f98226500f5d9a306931030188b88c23449e296340cd80d067af01f502f0cf6b1d0205103cf427c7a28032007c55ada82aeaf1833efdc34249bb671078c62ca95801adf5c0e56294731ebd86e0790435a136de4e5168fee104171f5652b6016e6dfd8604eb54ec301b848579e0071c0808b4a52c17e8387166e8d1cea0a433e9da7d2f0b59fde2020f2cfaaf57f306415e16212c2a80d31556ce502998ac11fab0f578742bcc1c369f73b6e84bc267a9c74b16b1c093cb0aac2a2caa53a27f5ada6304d07f58696649d8c204e4db2cecd96708d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">four-letter</span>      </label>    </div>    <!-- 添加确认按钮 -->    <button id="hbeConfirmBtn" class="hbe hbe-confirm-btn">Confirm</button>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> record </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/posts/735e5788.html"/>
      <url>/posts/735e5788.html</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>基于<strong>分治</strong>的思想，通过选择一个基准元素，将待排序序列分成两部分，使得左边的元素都小于等于基准元素，右边的元素都大于等于基准元素，然后<strong>递归</strong>地对两个子排序进行排序。 对于基准元素的选择，其一般是选择序列的第一个元素或者最后一个元素。<br>这个代码感觉效率比较低：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def quicksort(arr0):    if len(arr0) &lt;&#x3D; 1:        return arr0    pivot &#x3D; arr0[len(arr0) &#x2F;&#x2F; 2]  # 选择基准元素    left &#x3D; [x for x in arr0 if x &lt; pivot]  # 小于基准的元素    middle &#x3D; [x for x in arr0 if x &#x3D;&#x3D; pivot]  # 等于基准的元素    right &#x3D; [x for x in arr0 if x &gt; pivot]  # 大于基准的元素    return quicksort(left) + middle + quicksort(right)# 示例用法arr &#x3D; [3, 1, 7, 2, 5, 4, 3, 11, 2, 3, 4, 5, 6, 7, 8, 9, 0]sorted_arr &#x3D; quicksort(arr)print(sorted_arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用双指针（双边循环）实现的快速排序的代码示例（讲解<a href="https://www.bilibili.com/video/BV1at411T75o/?spm_id_from=333.337.search-card.all.click&vd_source=09b698923a25ef72eaa5a10289f42725">快速排序算法_哔哩哔哩_bilibili</a>）：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def quick_sort(arr, low, high):    if low &lt; high:        # 选择枢纽元素        pivot &#x3D; arr[low]        i &#x3D; low        j &#x3D; high        while i &lt; j:            # 从右往左找第一个小于枢纽的元素            while i &lt; j and arr[j] &gt;&#x3D; pivot:                j -&#x3D; 1            arr[i] &#x3D; arr[j]            # 从左往右找第一个大于枢纽的元素            while i &lt; j and arr[i] &lt;&#x3D; pivot:                i +&#x3D; 1            arr[j] &#x3D; arr[i]        # 将枢纽元素放到正确的位置        arr[i] &#x3D; pivot        # 递归排序左右两部分        quick_sort(arr, low, i - 1)        quick_sort(arr, i + 1, high)# 测试示例arr &#x3D; [9, 1, 0, 5, 4]quick_sort(arr, 0, len(arr) - 1)print(&quot;Sorted array:&quot;, arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的基本思想是通过不断地比较相邻的元素，将较大（或较小）的元素逐渐交换到列表的一端。在每一轮遍历中，将最大（或最小）的元素冒泡到列表的末尾，因此称为冒泡排序。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def bubble_sort(arr):    n &#x3D; len(arr)    # 遍历n-1轮    for i in range(n - 1):        # 每轮遍历比较相邻的元素        for j in range(n - 1 - i):            # 如果前一个元素大于后一个元素，则交换它们            if arr[j] &gt; arr[j + 1]:                arr[j], arr[j + 1] &#x3D; arr[j + 1], arr[j]# 测试示例arr &#x3D; [9, 1, 0, 5, 4]bubble_sort(arr)print(&quot;Sorted array:&quot;, arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序（Merge Sort）是一种基于分治思想的排序算法。它将待排序的数组分成两个较小的子数组，分别对两个子数组进行排序，然后将排好序的子数组合并成一个有序的数组。</p><p>归并排序的基本思想是不断地将数组一分为二，直到每个子数组只包含一个元素。然后，逐层合并相邻的子数组，直到最终得到完全排序的数组。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">def merge_sort(arr):    if len(arr) &lt;&#x3D; 1:        return arr    # 将数组一分为二    mid &#x3D; len(arr) &#x2F;&#x2F; 2    left &#x3D; arr[:mid]    right &#x3D; arr[mid:]    # 递归地对左右两个子数组进行排序    left &#x3D; merge_sort(left)    right &#x3D; merge_sort(right)    # 合并两个已排序的子数组    return merge(left, right)def merge(left, right):    merged &#x3D; []    i, j &#x3D; 0, 0    # 按照从小到大的顺序合并两个子数组    while i &lt; len(left) and j &lt; len(right):        if left[i] &lt;&#x3D; right[j]:            merged.append(left[i])            i +&#x3D; 1        else:            merged.append(right[j])            j +&#x3D; 1    # 将剩余的元素添加到合并后的数组中    while i &lt; len(left):        merged.append(left[i])        i +&#x3D; 1    while j &lt; len(right):        merged.append(right[j])        j +&#x3D; 1    return merged# 测试示例arr &#x3D; [9, 1, 0, 5, 4]sorted_arr &#x3D; merge_sort(arr)print(&quot;Sorted array:&quot;, sorted_arr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>超快速排序（Ultra-quick sort）：<a href="https://ac.nowcoder.com/acm/problem/blogs/50941">Ultra-QuickSort题目题解_牛客竞赛OJ</a>，模拟了冒泡排序，可以用冒泡排序记录，如果要速度的话，需要使用归并排序。这道题还考验了下对输入的理解。  <a href="https://www.acwing.com/solution/content/841/">AcWing 107. 超快速排序 - AcWing</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/e85d694a.html"/>
      <url>/posts/e85d694a.html</url>
      
        <content type="html"><![CDATA[<ul><li>二叉树的种类：满二叉树、完全二叉树（底层从左到右是连续的）、二叉搜索树（有序数值）、平衡二叉搜索树（高度差的绝对值不超过1）</li><li>二叉树的存储方式：链式存储，顺序存储</li><li>二叉树遍历方式：<ul><li>深度优先搜索：前中后序遍历，中节点的位置对应这个<code>前中后</code></li><li>广度优先搜索：层次遍历</li></ul></li><li>二叉树的定义（python版本）：<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>value <span class="token operator">=</span> valueself<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>self<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>几种遍历的示例：<img src="https://image.haoqin.vip/2023/06/fb75f85ba68e1ade5acb9304146c09c3.png" alt="image.png"></p><ul><li>前序遍历：ABDFGHIEC</li><li>中序遍历：FDHGIBEAC</li><li>后序遍历：FHIGDEBCA</li></ul><h1 id="递归法实现遍历"><a href="#递归法实现遍历" class="headerlink" title="递归法实现遍历"></a>递归法实现遍历</h1><h2 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h2><p>递归的三要素：</p><ul><li><strong>明确递归终止条件；</strong></li><li><strong>给出递归终止时的处理办法；</strong></li><li><strong>提取重复的逻辑，缩小问题规模。</strong><h2 id="简单题目"><a href="#简单题目" class="headerlink" title="简单题目"></a>简单题目</h2><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val&#x3D;0, left&#x3D;None, right&#x3D;None):#         self.val &#x3D; val#         self.left &#x3D; left#         self.right &#x3D; right# 前序遍历class Solution:    def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return []                left &#x3D; self.preorderTraversal(root.left)        right &#x3D; self.preorderTraversal(root.right)        return [root.val] + left + right# 后序遍历class Solution:    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return []        left &#x3D; self.postorderTraversal(root.left)        right &#x3D; self.postorderTraversal(root.right)        return left + right + [root.val]# 中序遍历&quot;&quot;&quot;shenglve&quot;&quot;&quot;return left + [root.val] + right<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="迭代法实现遍历"><a href="#迭代法实现遍历" class="headerlink" title="迭代法实现遍历"></a>迭代法实现遍历</h1><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>注意栈的顺序，在循环没有停下来的时候如何选择放入节点的顺序，什么时候要将节点的数值放入结果中。</p><h2 id="题目求解"><a href="#题目求解" class="headerlink" title="题目求解"></a>题目求解</h2><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val&#x3D;0, left&#x3D;None, right&#x3D;None):#         self.val &#x3D; val#         self.left &#x3D; left#         self.right &#x3D; right# 前序遍历class Solution:    def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return []        stack &#x3D; [root]        result &#x3D; []        while stack:            # 弹出节点            node &#x3D; stack.pop()            # 添加节点数值            result.append(node.val)            # 右节点 入栈            if node.right:                stack.append(node.right)            # 左节点 入栈            if node.left:                stack.append(node.left)        return result# 中序遍历class Solution:    def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:        if not root:            return []        stack &#x3D; []        result &#x3D; []        cur &#x3D; root        while cur or stack:            # 完成左节点的深度搜索            if cur :                stack.append(cur)                cur &#x3D; cur.left            else:                cur &#x3D; stack.pop()                result.append(cur.val)                cur &#x3D; cur.right        return result# 后序遍历#前面部分跟前序一样，最后结果翻转return result[::-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/posts/6534ce06.html"/>
      <url>/posts/6534ce06.html</url>
      
        <content type="html"><![CDATA[<p>在Python中可以使用列表（list）来实现队列和堆栈数据结构。</p><p><strong>队列</strong>（queue）是一种先进先出（First-In-First-Out，FIFO）的数据结构，可以使用列表实现。Python 中的列表支持在末尾添加元素和在列表开头删除元素，这正好符合了队列的特点。</p><p><strong>堆栈</strong>（stack）是一种后进先出（Last-In-First-Out，LIFO）的数据结构，同样可以使用列表实现。在 Python 中，列表的末尾是堆栈的顶部，可以使用列表的 append() 方法在末尾添加元素，使用 pop() 方法从末尾删除元素。</p><h1 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class MyQueue:    def __init__(self):        # in 负责 push 操作，out 负责 pop 工作        self.stack_in &#x3D; []        self.stack_out &#x3D; []    def push(self, x: int) -&gt; None:        # 将新元素放到 in 里面        self.stack_in.append(x)    def pop(self) -&gt; int:        if self.empty():            return None        # 判断out是否已经存入数据        if self.stack_out:                return self.stack_out.pop()        else:        # 将in中输入移动到out中            for i in range(len(self.stack_in)):                self.stack_out.append(self.stack_in.pop())            return self.stack_out.pop()    def peek(self) -&gt; int:        ans &#x3D; self.pop()  # pop功能已实现，复用        self.stack_out.append(ans)        return ans    def empty(self) -&gt; bool:        return not (self.stack_out or self.stack_in)# Your MyQueue object will be instantiated and called as such:# obj &#x3D; MyQueue()# obj.push(x)# param_2 &#x3D; obj.pop()# param_3 &#x3D; obj.peek()# param_4 &#x3D; obj.empty()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。<h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2>需要知道的知识：<code>popleft</code> 是 Python 中 <code>collections</code> 模块（内置）中 <code>deque</code>（双端队列）对象的一个方法。<code>popleft</code> 用于从双端队列的左侧移除并返回第一个元素。<br>在纸上进行相关流程的模拟有助于厘清思路。<pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class MyStack:    def __init__(self):        self.que &#x3D; deque()    def push(self, x: int) -&gt; None:        self.que.append(x)    def pop(self) -&gt; int:        if self.empty():            return None        for i in range(len(self.que) - 1):            self.que.append(self.que.popleft())        return self.que.popleft()    def top(self) -&gt; int:        return self.que[-1]    def empty(self) -&gt; bool:        return not self.que# Your MyStack object will be instantiated and called as such:# obj &#x3D; MyStack()# obj.push(x)# param_2 &#x3D; obj.pop()# param_3 &#x3D; obj.top()# param_4 &#x3D; obj.empty()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/posts/fc81fbfd.html"/>
      <url>/posts/fc81fbfd.html</url>
      
        <content type="html"><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1：<br>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]</p><p>示例 2：<br>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>本题涉及一个知识点：在Python中，多个变量可以同时接收一个元组的值，不存在先后顺序问题。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def reverseString(self, s: List[str]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify s in-place instead.        &quot;&quot;&quot;        left, right &#x3D; 0, len(s) - 1        while(left &lt; right):            s[left], s[right] &#x3D; s[right], s[left]            left +&#x3D; 1            right -&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p><p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p><p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p><p>示例:</p><p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p><h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>这种解法将反转定义一个函数来进行。同时对于字符串，如果索引超过最大值，会返回字符串的最后一个值，知道这个可以有效对反转的边界值进行判定。<br>固定区间的移动，可以考虑range的步长来执行。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def reverseStr(self, s: str, k: int) -&gt; str:        &quot;&quot;&quot;        1. 使用range(start, end, step)来确定需要调换的初始位置        2. 对于字符串s &#x3D; &#39;abc&#39;，如果使用s[0:999] &#x3D;&#x3D;&#x3D;&gt; &#39;abc&#39;。字符串末尾如果超过最大长度，则会返回至字符串最后一个值，这个特性可以避免一些边界条件的处理。        3. 用切片整体替换，而不是一个个替换.        &quot;&quot;&quot;        def reverse_substring(text):            left, right &#x3D; 0, len(text) - 1            while left &lt; right:                text[left], text[right] &#x3D; text[right], text[left]                left +&#x3D; 1                right -&#x3D; 1            return text                res &#x3D; list(s)        for cur in range(0, len(s), 2 * k):            res[cur: cur + k] &#x3D; reverse_substring(res[cur: cur + k])                return &#39;&#39;.join(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1： 输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><h2 id="解题-2"><a href="#解题-2" class="headerlink" title="解题"></a>解题</h2><p>在python中字符串是不可变类型，所以需要新建一个列表来进行操作。<br>方法1是常规的遍历操作，找到空字符后边进行添加指定字符，最后的join操作是将列表内的所有字符按照指定的分隔符连接在一块。<br>方法2是运用了双指针法，从后向前，一个指针负责在原字符上找空格，一个指针负责将新的字符填入。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;methon_1&quot;&quot;&quot;class Solution:    def replaceSpace(self, s: str) -&gt; str:        res &#x3D; []        for c in s:            if c &#x3D;&#x3D; &#39; &#39;:                res.append(&#39;%20&#39;)            else:                res.append(c)        return &quot;&quot;.join(res)&quot;&quot;&quot;methon_2&quot;&quot;&quot;class Solution:    def replaceSpace(self, s: str) -&gt; str:        counter &#x3D; s.count(&#39; &#39;)                res &#x3D; list(s)        # 每碰到一个空格就多拓展两个格子，1 + 2 &#x3D; 3个位置存’%20‘        res.extend([&#39; &#39;] * counter * 2)                # 原始字符串的末尾，拓展后的末尾        left, right &#x3D; len(s) - 1, len(res) - 1                while left &gt;&#x3D; 0:            if res[left] !&#x3D; &#39; &#39;:                res[right] &#x3D; res[left]                right -&#x3D; 1            else:                # [right - 2, right), 左闭右开                res[right - 2: right + 1] &#x3D; &#39;%20&#39;                right -&#x3D; 3            left -&#x3D; 1        return &#39;&#39;.join(res)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/posts/850f2080.html"/>
      <url>/posts/850f2080.html</url>
      
        <content type="html"><![CDATA[<p>哈希表是一种常见的数据结构，用于实现映射关系。在Python中，哈希表常被实现为字典（dictionary）类型，也就是Python中常用的一种数据类型。</p><p>哈希表基于哈希函数实现。哈希函数将输入映射到一个固定大小的输出，这个输出通常称为哈希值。哈希函数应该具有以下两个特点：</p><ol><li>相同的输入总是产生相同的输出。</li><li>不同的输入很难产生相同的输出。</li></ol><p>哈希表中每个元素都对应一个键和一个值。键通过哈希函数计算得到哈希值，然后根据哈希值存储在哈希表的相应位置。当需要查找一个键对应的值时，首先根据哈希函数计算键的哈希值，然后在哈希表中查找对应位置上的值即可。</p><p>一般来说啊，实现哈希表我们可以采用两种方法：<br>1、数组+链表<br>2、数组+二叉树</p><h1 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s = “anagram”, t = “nagaram” 输出: true</p><p>示例 2: 输入: s = “rat”, t = “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题使用数组来解决，数组是一种简单的哈希表。符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        char &#x3D; [0] * 26        b &#x3D; 0                for i in s:            char[ord(i)-ord(&#39;a&#39;)] +&#x3D;1        for ii in t:            char[ord(ii)-ord(&#39;a&#39;)] -&#x3D;1        for i in char:            if i !&#x3D; 0:                return False        return True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p><h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>这道题通过字典来进行解题，字典可以说是哈希表的一种常见形式，在进行两个数组相同元素的判断前，建立了一个字典来放置其中一个数组的元素，让元素作为字典的键，存在该元素则领该键对应的值为1. 还需要掌握的是字典的基本用法，如<code>dict.keys()</code></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:        val_dict &#x3D; &#123;&#125; # 创建空字典        ans &#x3D; []        for i in nums1:            val_dict[i] &#x3D; 1        for i_2 in nums2:            if i_2 in val_dict.keys() and val_dict[i_2] &#x3D;&#x3D; 1: # 判断键存在                ans.append(i_2)                val_dict[i_2] &#x3D; 0        return ans<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。<br>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong><br>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><h2 id="解题-2"><a href="#解题-2" class="headerlink" title="解题"></a>解题</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isHappy</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">happy_check</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>            sum1 <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">while</span> num<span class="token punctuation">:</span>                sum1 <span class="token operator">+=</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token operator">**</span> <span class="token number">2</span>     <span class="token comment"># 取余数得到一个整数，即个位数，取平方</span>                num <span class="token operator">=</span> num <span class="token operator">//</span> <span class="token number">10</span>             <span class="token comment"># 完成一位计算后，进一位</span>            <span class="token keyword">return</span> sum1         sum_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            n <span class="token operator">=</span> happy_check<span class="token punctuation">(</span>n<span class="token punctuation">)</span>            <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> n <span class="token keyword">in</span> sum_set<span class="token punctuation">:</span>             <span class="token comment"># 如果存在重复，则证明进入了循环。</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span>                <span class="token keyword">else</span> <span class="token punctuation">:</span>                    sum_set<span class="token punctuation">.</span>add<span class="token punctuation">(</span>n<span class="token punctuation">)</span>           <span class="token comment"># 添加出现过的数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h2 id="解题-3"><a href="#解题-3" class="headerlink" title="解题"></a>解题</h2><p>了解Python内置函数<code>enumerate</code>的用法：用于将一个可遍历的数据对象（如列表、元组、字符串等）组合为一个带有索引的序列，同时返回索引和对应的元素。简单的例子介绍：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">fruits &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;]for index, fruit in enumerate(fruits):    print(index, fruit)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这道题需要构建字典，将数组的内容作为键，索引作为值来构建字典。然后在通过对应的键值存在与否来进行搜索。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        nums_map <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> target <span class="token operator">-</span> value <span class="token keyword">in</span> nums_map<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>nums_map<span class="token punctuation">[</span>target <span class="token operator">-</span> value<span class="token punctuation">]</span> <span class="token punctuation">,</span> index<span class="token punctuation">]</span>            nums_map<span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> index        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四数相加II"><a href="#四数相加II" class="headerlink" title="四数相加II"></a>四数相加II</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p><p>0 &lt;= i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p><h2 id="解题-4"><a href="#解题-4" class="headerlink" title="解题"></a>解题</h2><p>建立字典，匹配关系一般从划分为两个部分来思考，所以两个数组两个数组来进行考虑，设定一个地方放一个数值，然后对应和的数值来进行匹配。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:        hash &#x3D; dict()        for n1 in nums1:            for n2 in nums2:                if n1 + n2 in hash:                    hash[n1 + n2] +&#x3D; 1                else:                    hash[n1 + n2] &#x3D; 1                count &#x3D; 0        for n3 in nums3:            for n4 in nums4:                if -(n3 + n4) in hash:                    count +&#x3D; hash[-(n3 + n4)]        return count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><h2 id="解题-5"><a href="#解题-5" class="headerlink" title="解题"></a>解题</h2><p>我的解法是使用map，利用第二个字符构建字典，然后查第一个字符能否在字典中完全寻找到：</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        strsame &#x3D; dict()        for n1 in magazine:            if n1 in strsame:                strsame[n1] +&#x3D; 1            else:                strsame[n1] &#x3D; 1                 for n2 in ransomNote:            if n2 in strsame :              if strsame[n2] &lt;&#x3D; 0 :                return False              else:                strsame[n2] -&#x3D; 1            else:                return False        return True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码随想录提出说用数组可以更加节约空间，都是小写字母，所以数组可以在26位内解决，但其实提交后没啥区别。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:        arr &#x3D; [0] * 26        for x in magazine:    # 记录 magazine里各个字符出现次数            arr[ord(x) - ord(&#39;a&#39;)] +&#x3D; 1        for x in ransomNote:  # 在arr里对应的字符个数做--操作            if arr[ord(x) - ord(&#39;a&#39;)] &#x3D;&#x3D; 0:  # 如果没有出现过直接返回                return False            else:                arr[ord(x) - ord(&#39;a&#39;)] -&#x3D; 1                return True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/posts/2362a8ea.html"/>
      <url>/posts/2362a8ea.html</url>
      
        <content type="html"><![CDATA[<p>链表是由一系列的结点组成，结点可以在运行时动态生成。每个结点包含两部分：<strong>数据域与指针域</strong>。数据域存储数据元素，指针域存储<strong>下一结点</strong>的指针。在python中需要通过定义类来实现链表的操作。<br><img src="https://image.haoqin.vip/2023/04/f3fb01164024ea33068e7f14dcfdd21c.png" alt="image.png"></p><p>head 保存首地址，item 存储数据，next 指向下一结点地址。<br>相关讲解参考：<a href="https://zhuanlan.zhihu.com/p/60057180">Python 数据结构之链表 - 知乎</a></p><h1 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>删除链表中等于给定值 val 的所有节点。</p><p>示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]</p><p>示例 2： 输入：head = [], val = 1 输出：[]</p><p>示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>链表需要具有首地址指针head，可以设置一个虚拟头结点在进行删除操作。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val&#x3D;0, next&#x3D;None):#         self.val &#x3D; val#         self.next &#x3D; nextclass Solution:    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:        dummy_head &#x3D; ListNode(next&#x3D;head) #添加一个虚拟节点        cur &#x3D; dummy_head        while(cur.next!&#x3D;None):            if(cur.next.val &#x3D;&#x3D; val):                cur.next &#x3D; cur.next.next #删除cur.next节点            else:                cur &#x3D; cur.next        return dummy_head.next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>需要先定义节点的类，然后在链表的初始化里定义一个虚拟的头结点。</p><pre class="line-numbers language-none"><code class="language-none">class Node(object):    def __init__(self,  x&#x3D;0, next &#x3D; None):        self.val &#x3D; x        self.next &#x3D; nextclass MyLinkedList:    def __init__(self):        self.head &#x3D; Node()        self.size &#x3D; 0     def get(self, index: int) -&gt; int:        if index &lt; 0 or index &gt;&#x3D; self.size:            return -1        cur &#x3D; self.head.next        while(index):            cur &#x3D; cur.next            index -&#x3D; 1                   return cur.val    def addAtHead(self, val: int) -&gt; None:        headnode &#x3D; Node(val)        headnode.next &#x3D; self.head.next        self.head.next &#x3D; headnode          # 只有head.next才是链表的第一个节点        self.size +&#x3D; 1      def addAtTail(self, val):        new_node &#x3D; Node(val)        cur &#x3D; self.head        while(cur.next):            cur &#x3D; cur.next        cur.next &#x3D; new_node        self.size +&#x3D; 1      def addAtIndex(self, index, val):        if index &lt; 0:            self.addAtHead(val)            return        elif index &#x3D;&#x3D; self.size:            self.addAtTail(val)            return        elif index &gt; self.size:            return        node &#x3D; Node(val)        pre &#x3D; self.head   # pre的用法，不是直接next，根据不同功能选择辅助变量        while(index):            pre &#x3D; pre.next            index -&#x3D; 1        node.next &#x3D; pre.next        pre.next &#x3D; node        self.size +&#x3D; 1    def deleteAtIndex(self, index):        if index &lt; 0 or index &gt;&#x3D; self.size:            return        pre &#x3D; self.head        while(index):            pre &#x3D; pre.next            index -&#x3D; 1        pre.next &#x3D; pre.next.next        self.size -&#x3D; 1  # Your MyLinkedList object will be instantiated and called as such:# obj &#x3D; MyLinkedList()# param_1 &#x3D; obj.get(index)# obj.addAtHead(val)# obj.addAtTail(val)# obj.addAtIndex(index,val)# obj.deleteAtIndex(index)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h2 id="解题-2"><a href="#解题-2" class="headerlink" title="解题"></a>解题</h2><p>第一种比较常规的解法，利用双指针来进行求解，在迭代的过程中实现对链表的逐步反转。<img src="https://image.haoqin.vip/2023/04/da1a4c3ba6bc89af7eade30a4e9d15ce.jpg" alt="SmartSelect_20230420_153519_Samsung Notes.jpg"><br>以1,2,3,4,5来举例的话，迭代的结果：<img src="https://image.haoqin.vip/2023/04/d91c4f9e82f27e4289653c15b7422e83.jpg" alt="SmartSelect_20230420_153622_Samsung Notes.jpg"></p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 双指针法# Definition for singly-linked list.# class ListNode:#     def __init__(self, val&#x3D;0, next&#x3D;None):#         self.val &#x3D; val#         self.next &#x3D; nextclass Solution:    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        cur &#x3D; head # 初始化为头节点        pre &#x3D; None # 初始化为空        while(cur !&#x3D; None):            temp &#x3D; cur.next # 暂存下一个节点位置            cur.next &#x3D; pre            pre &#x3D; cur       # 指针迭代            cur &#x3D; temp      # 指针迭代        return pre<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># 递归法（按照双指针法的思路）class Solution:    def reverseList(self, head: ListNode) -&gt; ListNode:                def reverse(pre,cur):            if not cur:             # 终止条件                return pre                            tmp &#x3D; cur.next            cur.next &#x3D; pre            return reverse(cur,tmp) # 类比迭代的赋值                return reverse(None,head)   # 初始设置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。<br><strong>输入：</strong> head = [1,2,3,4]<br><strong>输出：</strong> [2,1,4,3]</p><h2 id="解题-3"><a href="#解题-3" class="headerlink" title="解题"></a>解题</h2><p>需要创建虚拟头节点来方便操作，使用画图的方式厘清节点之间先后交换的关系。两个节点两个节点进行处理。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val&#x3D;0, next&#x3D;None):#         self.val &#x3D; val#         self.next &#x3D; nextclass Solution:    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:        headpoint &#x3D; ListNode(next &#x3D; head)        pre &#x3D; headpoint        # 判断当前是否存在两个节点可以进行交换        while pre.next and pre.next.next:            cur &#x3D; pre.next            cur2 &#x3D; pre.next.next # cur和cur2是当前要处理的两个节点            cur.next &#x3D; cur2.next            cur2.next &#x3D; cur            pre.next &#x3D; cur2            pre &#x3D; pre.next.next # 移动节点处理的顺序，进两位                    return headpoint.next   # 返回头节点的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个节点，并且返回链表的头节点。</p><h2 id="解题-4"><a href="#解题-4" class="headerlink" title="解题"></a>解题</h2><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val&#x3D;0, next&#x3D;None):#         self.val &#x3D; val#         self.next &#x3D; nextclass Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:        head_dummy &#x3D; ListNode()        head_dummy.next &#x3D; head        slow, fast &#x3D; head_dummy, head_dummy        while(n&gt;&#x3D;0): #fast先往前走n+1步            fast &#x3D; fast.next            n -&#x3D; 1        while(fast!&#x3D;None):            slow &#x3D; slow.next            fast &#x3D; fast.next        #fast 走到结尾后，slow的下一个节点为倒数第N个节点        slow.next &#x3D; slow.next.next #删除        return head_dummy.next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。<img src="https://image.haoqin.vip/2023/06/c04e2829ab59c7c81575227eec4db11a.png" alt="image.png"></p><h2 id="解题-5"><a href="#解题-5" class="headerlink" title="解题"></a>解题</h2><p>首先计算链表的长度，通过其相交节点后一样的特性，让长的链表的指针进行移动，然后两个链表来进行比较。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val &#x3D; x#         self.next &#x3D; Noneclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:        lenA, lenB &#x3D; 0, 0        cur &#x3D; headA        while cur:            cur &#x3D; cur.next            lenA +&#x3D; 1        cur &#x3D; headB        while cur:            cur &#x3D; cur.next            lenB +&#x3D; 1        curA, curB &#x3D; headA, headB        if lenB &lt; lenA:            curA, curB &#x3D; curB, curA            lenA, lenB &#x3D; lenB, lenA        for _ in range(lenB - lenA):            curB &#x3D; curB.next        while curA:            if curA &#x3D;&#x3D; curB:                return curA            else:                curA &#x3D; curA.next                curB &#x3D; curB.next        return None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/posts/340249a9.html"/>
      <url>/posts/340249a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol start="704"><li>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。<br>示例：<pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9     输出: 4       解释: 9 出现在 nums 中并且下标为 4     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>条件：</li></ol><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>思路：二分法是一种常用的搜索算法，也称为二分查找或折半查找。二分法针对的是一个有序的数组，通过将数组从中间分开，确定目标值可能存在的区间，然后不断缩小区间直到找到目标值为止。二分法的时间复杂度为 O(log n)，相较于线性搜索的 O(n)，它具有更高的效率。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def search(self, nums: List[int], target: int) -&gt; int:        left, right &#x3D; 0, len(nums) - 1  # 定义target在左闭右闭的区间里，[left, right]        while left &lt;&#x3D; right:            middle &#x3D; left + (right - left) &#x2F;&#x2F; 2                        if nums[middle] &gt; target:                right &#x3D; middle - 1  # target在左区间，所以[left, middle - 1]            elif nums[middle] &lt; target:                left &#x3D; middle + 1  # target在右区间，所以[middle + 1, right]            else:                return middle  # 数组中找到目标值，直接返回下标        return -1  # 未找到目标值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p><p>示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p><h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><p>快慢指针是一种常见的指针操作技巧，常用于解决链表中的问题。快指针每次移动两个节点，慢指针每次移动一个节点，通过快慢指针的比较，可以快速定位链表中的某些位置，或者判断链表是否存在环。<br>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong> </p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置<pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def removeElement(self, nums: List[int], val: int) -&gt; int:        # 快慢指针        fast &#x3D; 0  # 快指针        slow &#x3D; 0  # 慢指针        size &#x3D; len(nums)        while fast &lt; size:  # 不加等于是因为，a &#x3D; size 时，nums[a] 会越界            # slow 用来收集不等于 val 的值，如果 fast 对应值不等于 val，则把它与 slow 替换            if nums[fast] !&#x3D; val:                nums[slow] &#x3D; nums[fast]                slow +&#x3D; 1            fast +&#x3D; 1        return slow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><h2 id="解题-2"><a href="#解题-2" class="headerlink" title="解题"></a>解题</h2><p>思路：运用双指针法，从数组的两侧开始，跟移除元素的快慢指针有类似的使用用法。通过这种方式，双指针法可以在 $O(n)$ 的时间复杂度内解决很多数组问题，如求和、求平方和、求中位数等。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def sortedSquares(self, nums: List[int]) -&gt; List[int]:        start &#x3D; 0        final &#x3D; -1             new &#x3D; [-1] * len(nums)   # 创建一定长度的元素初始值为1的数组        for i in range(len(nums)):            sm &#x3D; nums[start] ** 2            fm &#x3D; nums[final] ** 2            if sm &gt;&#x3D; fm:                new[-i-1] &#x3D; sm                start +&#x3D; 1            else:                new[-i-1] &#x3D; fm                final -&#x3D; 1        return new<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：</p><p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><h2 id="解题-3"><a href="#解题-3" class="headerlink" title="解题"></a>解题</h2><p>思路：类似双指针法的滑动窗口类型，一个指针在前，通过对窗口的移动来进行判断目标的达成与否。</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Solution:    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:        i &#x3D; 0        sum &#x3D; 0        length &#x3D; len(nums) + 1     # 定义一个比数组长度大的数        for j in range(len(nums)):            sum +&#x3D; nums[j]            while sum &gt;&#x3D; target:   # 使用while进一步缩小数组长度                length &#x3D; min(length, j-i+1)                sum -&#x3D; nums[i]                i +&#x3D;1        return 0 if length &gt; len(nums) else length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><h2 id="解题-4"><a href="#解题-4" class="headerlink" title="解题"></a>解题</h2><p>思路：注意循环区间的左右侧的开闭情况，保持每一个方向上的运行情况保持一致。</p><pre class="line-numbers language-none"><code class="language-none">class Solution:    def generateMatrix(self, n: int) -&gt; List[List[int]]:        nums &#x3D; [[0] * n for _ in range(n)]  # 创建一个n*n的二维列表        startx, starty &#x3D; 0, 0               # 起始点        loop, mid &#x3D; n &#x2F;&#x2F; 2, n &#x2F;&#x2F; 2          # 迭代次数、n为奇数时，矩阵的中心点        count &#x3D; 1                           # 计数        for offset in range(1, loop + 1) :      # 每循环一层偏移量加1，偏移量从1开始            for i in range(starty, n - offset) :    # 从左至右，左闭右开                nums[startx][i] &#x3D; count                count +&#x3D; 1            for i in range(startx, n - offset) :    # 从上至下                nums[i][n - offset] &#x3D; count                count +&#x3D; 1            for i in range(n - offset, starty, -1) : # 从右至左                nums[n - offset][i] &#x3D; count                count +&#x3D; 1            for i in range(n - offset, startx, -1) : # 从下至上                nums[i][starty] &#x3D; count                count +&#x3D; 1                            startx +&#x3D; 1         # 更新起始点            starty +&#x3D; 1        if n % 2 !&#x3D; 0 :# n为奇数时，填充中心点            nums[mid][mid] &#x3D; count         return nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Actions &amp;&amp; Cloudflare Pages 部署</title>
      <link href="/posts/519a1be4.html"/>
      <url>/posts/519a1be4.html</url>
      
        <content type="html"><![CDATA[<p>执行此次部署的初心是看重cloudflare pages的访问速度较快，并且可以通过自动化部署，将本地文件保存在网络端，实现备份工作。</p><ul><li>前期配置参考<a href="https://blog.csdn.net/wbsu2004/article/details/122661116">用GitHub Actions自动部署Hexo_github action部署hexo_杨浦老苏的博客-CSDN博客</a> ，执行到创建目录这一步。期间出现了无法推送到github的问题，主要通过重新确认用户名和邮箱信息，以及进行了强制推送更新<code>git push -f origin main</code>来进行解决。</li><li>具体的yml文件内容参考<a href="https://blog.kecho.top/2022/%E5%B0%86%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3%20Cloudflare%20Pages"></a><a href="https://blog.kecho.top/2022/%E5%B0%86%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3">https://blog.kecho.top/2022/将博客迁移至</a> Cloudflare Pages修改了自己的github信息上去，同时将其中的node版本设置为自己电脑里的12.22.1版本。同时在部署里设置环境变量的版本号。</li><li>在部署的时候出现类似这样的问题：<strong>**<code>atal: No url found for submodule path ‘xxx/xxx’ in .gitmodules</code></strong> 采取的解决方法是：清除本地缓存，从暂存区中删除该文件夹，类似<code>git rm --cache themes/hexo-theme-matery</code> ，然后在推送到github仓库。</li><li><a href="https://docs.github.com/zh/desktop/contributing-and-collaborating-using-github-desktop/making-changes-in-a-branch/pushing-changes-to-github">推送更改到 GitHub - GitHub 文档</a> 在实现了自动化部署后，除了在bash界面进行push操作，还可以通过Github Desktop来执行对分支的修改以及推送更新的工作。</li></ul><p>目前访问cloudflare pages的访问速度并未很直接地感受到提升，所以进一步的更换自定义域名到其网页上的工作有待进一步商榷，暂时告一段落。</p><hr><p>决定投入cloudflare pages的怀抱，主要觉得其可以配合自动化部署，同时其网页的加载一般是在内容都准备好的时候再加载，这种风格我觉得挺好的，不用网页只加载一半来访问，那样体验比较差。</p><p>使用cloudflare进行域名解析的时候出现重定向次数过多时候的解决方法：<a href="https://blog.csdn.net/qq_30499345/article/details/123107443">关于CloudFlare SSL/TLS 加密模式的详解以及301 Moved Permanently 报错出现的原因-CSDN博客</a></p><hr><p>在进行hexo-blog-encrypt的插件修改过程中，走了一堆弯路。最后发现本地修改时无效的，工作流中进行部署的时候重新安装了依赖项，所以需要在package.json文件夹中指定新的依赖的地址，可以通过fork他人的github仓库后进行修改，然后指定代码格式为：   <code>&quot;hexo-blog-encrypt&quot;: &quot;git+https://github.com/HaoqinChen/hexo-blog-encrypt&quot;,</code></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路径规划算法简介</title>
      <link href="/posts/d510a235.html"/>
      <url>/posts/d510a235.html</url>
      
        <content type="html"><![CDATA[<p>关于<strong>路径规划</strong>的定义，在不同的地方有着不同的理解，一般常规的理解是到达不同节点的路径选择，也就是说其在某些场景下可以等价为任务规划，寻找得到任务顺序。<br><strong>运动规划</strong>的定义较为广发，涉及到运动体在运动过程中的状态和动作，其可以理解成包括<strong>路径规划和轨迹规划</strong>，轨迹规划在路径规划的基础上包括了<strong>时间和速度</strong>等信息。</p><h1 id="路径规划概念"><a href="#路径规划概念" class="headerlink" title="路径规划概念"></a>路径规划概念</h1><p>在路径规划中，通常会涉及到两个重要的概念：<strong>配置空间和工作空间</strong>。</p><ul><li>配置空间（Configuration Space）。配置空间是机器人学中一个非常重要的概念，它是指所有可能的机器人<u>姿态或位置的集合</u>。在配置空间中，每个元素代表机器人的一个可行的状态或位置。配置空间通常是高维的，因为机器人的姿态或位置通常由多个参数决定，例如，关节角度、末端执行器的位置和方向等。</li><li>工作空间（Workspace）。工作空间是机器人能够到达的所有可能位置的集合。在机器人学中，通常将机器人视为一个刚体，并将其在<u>三维空间</u>中移动，因此，机器人的工作空间通常是一个三维空间。工作空间的大小和形状取决于机器人的几何形状、关节限制以及环境的约束等。</li></ul><p>进行路径规划时，要将工作空间转换到配置空间中，即将机器人转化为<strong>一个质点</strong>，同时将障碍物按照机器人的体积<strong>进行膨胀</strong>。</p><p>路径规划算法主要可分成两种，一种是<strong>基于搜索</strong>结果的规划，另一类便是<strong>基于采样</strong>的规划。相关知识的搜集主要来源于<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU1NjEwMTY0Mw==&action=getalbum&album_id=2430883367362592769&scene=173&from_msgid=2247557116&from_itemidx=1&count=3&nolastread=1#wechat_redirect">古月居——路径规划算法</a></p><h2 id="常见的列表类型"><a href="#常见的列表类型" class="headerlink" title="常见的列表类型"></a>常见的列表类型</h2><p>在路径规划算法中，通常会用到多个不同的列表来存储不同的信息，以辅助路径的搜索和规划。以下是一些常见的列表类型及其作用：</p><ul><li>开放列表（open list）：存储当前已经发现但尚未被探索的节点，通常按照节点到起点的距离（或代价）排序，以便在下一次选择探索节点时能够优先选择距离起点较近的节点。</li><li>关闭列表（closed list）：存储已经被探索过的节点，以避免重复探索相同的节点。</li><li>路径列表（path）：存储当前已经探索过的节点构成的路径，用于在搜索过程中回溯和更新最优路径。</li><li>障碍物列表（obstacle）：存储障碍物的位置和形状信息，以便在路径规划过程中进行障碍物检测和避障。</li><li>地图列表（map）：存储环境地图信息，包括地图大小、起点和终点位置、障碍物位置和形状等</li></ul><h1 id="图搜索算法"><a href="#图搜索算法" class="headerlink" title="图搜索算法"></a>图搜索算法</h1><p>两种针对无权图的基本图搜索算法：<strong>深度优先搜索(Depth First Search, DFS)</strong>、<strong>广度优先搜索(Breadth First Search, BFS)</strong>。它们的区别在于openlist(后面介绍)所选用的数据结构类型不同，前者使用栈，后者使用队列。</p><p>启发式搜索算法：<strong>贪婪最佳优先算法(Greedy Best First Search, GBFS)</strong>，用来提高搜索效率，但是不能确保找到最优路径。</p><p>经典的算法：Dijkstra算法、A*算法，前者是广度优先算法(BFS)在带权图中的扩展，后者则是在前者中加入启发函数得到的算法，兼顾效率和完备性。</p><h1 id="基于采样的算法"><a href="#基于采样的算法" class="headerlink" title="基于采样的算法"></a>基于采样的算法</h1><p>基于采样的路径规划算法是一类常用的路径规划算法，它通过在配置空间中<strong>随机采样</strong>一些点来构建一棵采样树，然后从起点开始，通过一定的策略在采样树上搜索一条到达目标点的路径。</p><p>RRT和它的变种算法。这类算法的核心在于随机采样，从<strong>父节点</strong>开始，随机在地图上生成<strong>子节点</strong>，连接父子节点并进行<strong>碰撞检测</strong>，若无碰撞，就扩展该子节点。</p><p><strong>Rapidly-exploring Random Tree (RRT)算法</strong>，其主要思想是从起点开始，不断向前延伸一棵树，直到找到目标点。具体来说，该算法随机生成一些点，并找到<strong>树上最近的节点</strong>，然后向该方向<strong>延伸一条新的分支</strong>，并将其加入到树中。在搜索过程中，该算法会根据搜索的进展情况不断<strong>调整采样点的位置</strong>，以便更好地搜索到最优路径。RRT算法的优点是能够高效地搜索到配置空间中的大部分区域，但是在搜索过程中可能会出现一些不必要的分支，从而影响搜索效率。</p><p><strong>参考文献</strong><br><a href="https://mp.weixin.qq.com/s?__biz=MzU1NjEwMTY0Mw==&mid=2247576873&idx=1&sn=2cfc8582718433666eda418c13ec823e&chksm=fbc9d44dccbe5d5b63ca665dc42c9f229c19ac194f94fed6f5dced2ffadfac96e92ed258ed52&scene=90&sessionid=1678277400&subscene=236&key=7dfc46ca2556f0c5191ef365a0f364ec2c71e444b8c30907db86bb03bf56c6fc2fd9116e54eda9fa7e19f474e7819e3f6a1c9dc80225a95b5afd77d6d42875a923cb3acceda5778677053fcf793b467e6385d46acbe5c88c939b2d874d96461ec02631934722e88caece93375846619438fd207431d7950aafdb0eed06da7eb9&ascene=0&uin=MTExMjkzNDc2Nw%3D%3D&devicetype=Windows+8+x64&version=6309001c&lang=zh_CN&countrycode=CN&exportkey=n_ChQIAhIQ9dfYXgvztlMdv13BrVdQjhLfAQIE97dBBAEAAAAAANb6LOBvlPUAAAAOpnltbLcz9gKNyK89dVj0tdCpXox340xxN7ab2YveU6d6%2FLwofLcntn6OIs1SDeunfhNXcJY5QDvlBKgPsTMEsTWiPpeb41aXdNfEKdW3DmK4zK3cW4qEJn%2BvRAVCarW3iynV6WGHfj4Iaj5jOZRtNHP4Eky84Wol4H5JqgAWtS%2FchxF%2FltpO29Fs454PoAMMztWW4Vh4ize3wH4eVVMq8jjEDWWQ7NelSMJHy0qJApP0CgLRN4Cf%2BOwBgrrthMClLeIRQqgiV9g%3D&acctmode=0&pass_ticket=%2B6pm909DkguDzuvGgvJ%2BwVNByqSZAIQHwquRGicz1BRehXDZqRHngYXCVvxDYOM4a%2BO12lJ0V0iBJ7TNPwZ5xA%3D%3D&wx_header=1&fontgear=2">图搜索算法</a></p>]]></content>
      
      
      <categories>
          
          <category> UAV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python二级基础知识</title>
      <link href="/posts/2aa35565.html"/>
      <url>/posts/2aa35565.html</url>
      
        <content type="html"><![CDATA[<p>此篇记录在学习Python计算机二级时候遇到的一些知识点，希望在这种方式中能够增进自己对这门语言的了解。</p><h2 id="1-程序设计基本方法"><a href="#1-程序设计基本方法" class="headerlink" title="1. 程序设计基本方法"></a>1. 程序设计基本方法</h2><ul><li>Python解释器本身并不直接支持自然语言编程，但可以使用各种NLP库和工具来支持自然语言编程</li><li>Python语言是一种既支持面向过程也支持面向对象的采用解释型方法执行程序的高级脚本语言。解释是将源代码逐条转换成目标代码同时逐条运行目标代码的过程，不是一次性翻译的。</li><li>编译是将源代码转换成目标代码的过程。</li></ul><h2 id="2-python基本语法"><a href="#2-python基本语法" class="headerlink" title="2. python基本语法"></a>2. python基本语法</h2><ul><li>Python中，变量名的命名规则:以字母或下划线开头，后面跟字母、下划线和数字﹔不能以数字开头。</li><li>常用的注释方法有两种，#注释和三引号注释，其中三引号注释就是将注释内容修饰为字符串类型。</li><li>“unexpected indent”翻译成中文就是意外缩进，也就是程序中含有不符合编码要求的缩进。</li><li>在Python语言中，赋值不需要两侧数据类型一致，在赋值操作之后，左侧变量将会自动变成右侧对应的数据类型。</li><li><code>\\0</code>是一个字符串中的转义字符，表示空字符。空字符在字符串中用于表示字符序列的结束。对于空字符，它在 Unicode 字符集中仍然是一个字符。</li><li>在 Python 中，<code>count()</code>是一个字符串对象的方法（也可用于列表、元组等可迭代对象），用于返回一个指定子字符串在原字符串中出现的次数。</li><li><code>eval()</code>函数的参数必须是字符串类型</li><li><code>input()</code>函数获取用户输入的信息，并将信息组成一个字符串处理，input()函数含有参数，用于提示用户输入。用户输入信息时，使用回车也就是想换一行时，会停止输入结束input()函数。本题选择B选项。</li></ul><h2 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3. 基本数据类型"></a>3. 基本数据类型</h2><ul><li>在比较字符串时，Python 会按照 ASCII 码表顺序进行比较，即小写字母比大写字母大，而数字比字母小。第一个不同的字母出现时便完成了比较。字符串比较大小按照以下规则:<code>0&lt;9&lt;A&lt;Z&lt;a&lt;z</code></li><li>符号&amp;=是Python中的位运算符，表示按位与运算并赋值操作。具体意思是将等号左边的变量与等号右边的值进行按位<strong>与</strong>运算，并将运算结果赋值给左边的变量。</li><li><code>//</code>是整除运算,<code>%</code>是求余运算，求余运算可以是浮点数之间的运算。</li><li>字符应视为长度为1的字符串;字符串中的字符不可以进行数学运算，如果是数字字符串需要将其转换为数值类型方可计算﹔字符津可进行切片，但不能赋值。</li><li>Python的整数类型没有长度限制;浮点类型有长度限制</li><li>对于十进制数，它只能表示以进制数的质因子为分母的分数。10的质因子有2和5</li><li>复数的实部可以单独存在,但是虚部不可以单独存在。计算后若虚部为0，j不可以省略。</li><li><code>str()</code>函数是将参数转化为字符串类型，题目中参数是10/2，计算结果为浮点数5.0，所以转换的结果为’5.0’。当参数是表达式的时候会先计算出结果，再进行转换</li><li><code>eval()</code>函数内部先执行字符串的拼接，然后再用evral函数去掉字符串的引号，首先字符串100+1+2=1001+2)，然后将字符串101+2通过eval0函娄专化得到1001+2=1003。</li><li>在Python中，<code>complex()</code>是一个用于创建一个复数对象的内置函数。接受两个参数，第一个参数是实部，第二个参数是虚部。</li><li><code>int()</code>函数可以将整数<strong>字符串</strong>转化为整数，也可以将浮点数转化为整数，但是浮点数字符串不能转化为整数</li><li><code>split()</code>方法是将字符串通过括号内的参数字符切割，没有参数，默认以空白字符切割。</li><li>将字符串str所有的字符都大写的方法是<code>str.upper()</code></li><li><code>strip()</code>方法是去除字符串首尾两端与参数相同的字符，无论数量。<code>replace()</code>方法，此方法是将字符串中与第一个参数相同的字符替换为第二个参数.字符串方法replace()用来替换字符串中指定字符或子字符串的所有重复出现，每次只能替换一个字符或一个字符串，把指定的字符串参数作为一个整体对待。该方法并<strong>不修改原字符</strong>串,而是返回一个新字符串。</li><li><code>join()</code>是 Python 中字符串对象的一个内置方法，用于将一个可迭代对象中的元素连接成一个字符串</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 使用 join() 方法连接字符串列表</span>s1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token string">'world'</span><span class="token punctuation">]</span>s2 <span class="token operator">=</span> <span class="token string">'_'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span>  <span class="token comment"># 'Hello_world'</span><span class="token comment"># 使用 join() 方法连接元组中的字符串</span>s3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'am'</span><span class="token punctuation">,</span> <span class="token string">'learning'</span><span class="token punctuation">,</span> <span class="token string">'Python'</span><span class="token punctuation">)</span>s4 <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s4<span class="token punctuation">)</span>  <span class="token comment"># 'I am learning Python'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在 Python 中，<code>index()</code>是字符串对象的一个内置方法，用于在字符串中查找子字符串并返回其第一次出现的索引。</li><li><code>center()</code>是字符串对象的一个内置方法，它可以将字符串居中对齐，并在两侧填充指定的字符或空格。第一个参数指定总宽度，第二个参数指定需要填充的字符。</li><li><code>isspace()</code>是 Python 字符串对象的一个内置方法，用于判断一个字符串是否只包含空格（包括制表符、换行符、回车符等）。</li><li>在 Python 中，可以使用前缀 “0x” 表示一个十六进制数，后跟所需的十六进制数字。它使用了 16 个字符（0-9，A-F）来表示数码，其中 A-F 表示 10-15。八进制数，’0o’ 或 ‘0O’ 前缀。二进制数，’0b’ 或 ‘0B’ 前缀</li><li>Python的逻辑运算符,and是两个操作数都为真，结果才为真; not是反转操作数的逻辑状态; or是只要有一个操作数为真，结果就为真。</li><li><code>string.printable</code>包含所有可打印的 ASCII 字符，包括数字、字母、标点符号和空格等。</li></ul><h2 id="4-程序控制结构"><a href="#4-程序控制结构" class="headerlink" title="4. 程序控制结构"></a>4. 程序控制结构</h2><ul><li><p>SyntaxError此异常只有当程序语法出现错误，不能正常继续下去，才会产生这种异常。</p></li><li><p>用于异常处理逻辑的保留字有try、except、else、finally.</p></li><li><p>Python语言在3种基本控制逻辑〈顺序结构、选择结构（分支结构〉、循环结构）上进行了适当的扩展。在分支结构原理的基础上，Python增加了异常处理，使用try-except保留字。</p></li><li><p><code>find()</code> 和 <code>index()</code>都是 Python 中字符串对象的方法，<code>start</code>和 <code>end</code>分别是查找的起始和结束位置。用于在字符串中查找子字符串。它们的主要区别在于，当子字符串不存在时，它们的返回值不同：</p><ul><li><code>find()</code> 方法在找不到子字符串时会返回 -1；</li><li><code>index()</code> 方法在找不到子字符串时会抛出 ValueError 异常。</li></ul></li><li><p>Python 中的二分支结构可以使用三元表达式来精简表示，语法格式如下：<code>&lt;expression1&gt; if &lt;condition&gt; else &lt;expression2&gt;</code></p><p>示例：<code>x = 1 if x &gt;= 0 else -1</code></p></li><li><p>在Python语言中，遍历循环中被遍历的数据需为多元素类型，最常见的如:字符串、列表、元组、字典或集合等。</p></li></ul><h2 id="5-组合数据类型"><a href="#5-组合数据类型" class="headerlink" title="5. 组合数据类型"></a>5. 组合数据类型</h2><ul><li>Python中最常用的组合数据类型有3大类，分别是<strong>集合类型、序列类型〈典型代表是字符串类型和列表类型）和映射类型（典型代表是字典类型)</strong>。</li><li>字典的<code>get(key default)</code>方法:键存在则返回对应值，否则返回默认值。</li><li>Python只有一种内置的映射类型，就是字典参考</li><li><code>pop()</code>方法:键存在则返回相应值，同时删除键值对。pop()方法可以接受一个可选的参数，表示要移除的元素的索引位置。如果不传入参数，则默认移除并返回列表的最后一个元素。</li><li><code>get()</code>方法:若访问的项不存在于字典中，返回默认值，若存在，则返回键对应的值;</li><li><code>popitem()</code>方法：随机从字典中取出一个键值对，以元组<code>(key, value)</code>形式返回，同时将该键值对从字典中删除。</li><li><code>remove()</code>删除集合中指定的元素，元素不存在则产生KeyError异常。</li><li>创建元组时，即使元组中仅包含一个元素，也要再这个元素之后<strong>添加逗号</strong>。</li><li><code>d.values()</code>是 Python 字典（<code>dict</code>）类的一个方法，用于返回该字典中所有值组成的视图（view）对象，视图对象是一个可迭代的对象，其中包含了字典中所有的值。可以通过将视图对象转化为列表或集合等可迭代的对象，对这些值进行处理或者遍历操作。</li><li><code>items()</code> 是一个字典方法，它可以返回一个元素为键值对的列表。</li><li><code>ls.remove(x)</code>是删除列表1s中出现的第一个元素x，而不是删除列表s中所有的x元素</li></ul><h2 id="6-文件和数据格式化"><a href="#6-文件和数据格式化" class="headerlink" title="6. 文件和数据格式化"></a>6. 文件和数据格式化</h2><ul><li>文本文件和二进制文件的存储方式不同，所以文本文件不可以用二进制文件方式读入。</li><li>Python为源文件指定的默认字符编码是:UTF-8。</li><li><code>writelines</code>是 Python 中文件对象的一个方法，它可以将一个包含多个字符串的可迭代对象（例如列表）写入到文件中。</li><li>文件对象的<code>seek()</code>方法用来定位文件的读/写位置，参数0为文件开头，参数2为文件结尾。<code>tell()</code>方法用来返回文件指针的当前位置。</li><li>在Python中，以写模式打开文件的同时，是无法进行读操作的，因为在写模式下打开文件时，文件指针指向文件开头，如果要读取文件的内容，需要先将文件指针移动到合适的位置。如果需要以写模式打开文件并进行读操作，可以先以读模式打开文件读取内容，然后关闭文件后再以写模式打开文件进行写操作。</li><li>在Python文件的打开方式中，<code>&#39;a&#39;</code>为只写方式打开，若文件存在，内容追加在原文件内容后面。</li><li>在Python中，打开模式为<code>&quot;x&quot;</code>表示以独占模式创建文件。如果指定的文件名已经存在，则无法创建文件并会引发FileExistsError异常。只有当指定的文件名不存在时，才会创建一个新文件。</li><li><strong>一维数据</strong>由对等关系的有序或无序数据构成，采用线性方式组织，对应于数学中的集合或数组的概念</li><li><strong>二维数据</strong>由关联关系构成，采用表格方式组织，对应于数学中的矩阵</li><li><strong>高维数据</strong>由键值对类型的数据组成，采用对象方式组织</li><li>在Python语言中，二维列表对象输出为CSV格式文件采用遍历循环和字符串的<code>join()</code>方法相结合。<code>split()</code>方法一般在将文件中的数据转化为列表时使用。</li><li>以英文逗号分隔的存储格式叫做<strong>CSV格式</strong>(Comma-Separated Values，即逗号分隔值）。CSV是一种通用的、相对简单的文件格式，最广泛的应用是在程序之间转移表格数据。CSV没有通用标准规范，使用的字符编码同样没有被指定，但ASCII是最基本的通用编码。</li><li>如果要同时读取和写入文件，可以使用 “r+” 模式打开文件。这个模式表示文件以读写方式打开，文件指针放在文件的开头。</li><li>Python中<code>write()</code>函数要求写入类型为字符串类型。如果需要写入其他类型的数据，需要先将其转换为字符串类型.<code>fo.writelines(8)</code>是指直接将列表类型的各元素连接起来写入文件</li></ul><h2 id="7-函数和代码复用"><a href="#7-函数和代码复用" class="headerlink" title="7. 函数和代码复用"></a>7. 函数和代码复用</h2><ul><li>在Python中，字符编码以UInicode编码存储。<code>chr(x)</code>和<code>ord(x)</code>函数用于在单字符和Unicode编码值之间进行转换。chr(x)函数返回Unicode编码对应的字符，ord(x)函数返回单字符x对应的Unicode编码.</li><li><code>int()</code>函数可以将整数字符串转换成整数，也可以将浮点数转化为整数，但是不能将其他字符串转换成整数</li><li><code>id()</code>函数的返回值是对象的内存地址，属于数字类型。</li><li>在实参面前加一个星号”*”表示将一个序列或可迭代对象<strong>展开成单独的元素</strong>。这意味着函数会将序列或可迭代对象中的每个元素都视为单独的参数进行处理，而不是将整个序列或可迭代对象作为一个参数处理。</li><li>当<code>max()</code>函数的参数是字典时，那么返回值就是字典的键的最大值。</li><li><code>round(x,d)</code>函数是指对x四舍五入，保留d位小数，无参数d则返回四舍五入的整数值。</li><li><code>divmod()</code>是一个 Python 内置函数，它有两个参数 a 和 b，并返回元组 (a // b, a % b)，其中 “//“ 表示整除，”%” 表示取余。它的功能是将两个数进行整除运算并返回商和余数。</li><li>如果在函数内部想要修改全局变量的值，需要使用 <code>global</code>关键字进行声明。在不使用 <code>global</code>声明时，在函数内部对变量的赋值只会创建一个新的局部变量，并不会修改全局变量的值。</li><li>对于空格字符串，<code>all()</code>返回 <code>True</code>，因为所有的字符都是非空字符，而 <code>any()</code>返回 <code>True</code>，因为至少含有一个非空字符。空字符对应的是False。</li><li>点数3.0和整数3具有相同的值，硬件执行单元、计算机指令处理方法和数据类型均不相同。</li><li>在Python中，<code>lambda</code>是一个关键字，用于创建匿名函数。匿名函数是指不需要定义函数名称，而是可以直接定义函数的表达式。它的一般形式如下：<code>lambda argument_list: expression</code>。其中，<strong>argument_list表示函数的参数列表，可以包括多个参数，用逗号分隔；expression表示函数的表达式，用于对参数进行计算，并返回计算结果。</strong>lambda表达式的计算结果是一个函数对象，可以赋值给一个变量，也可以直接使用。它通常用于需要临时定义一个简单的函数的场合，比如排序、过滤、映射等操作。</li><li>在 Python 函数中使用默认参数时，不需要使用空字符。当定义函数时，可以给某些参数指定默认值，这些参数就成为了默认参数。在调用函数时，如果不传递这些参数的值，就会使用默认值。</li><li><code>title()</code>函数把单词首字母大写</li><li>在 Python 中，关键字参数是一种可以在函数调用时指定形参名称的方式。使用关键字参数可以使代码更加易读和易维护，特别是在函数有许多参数的情况下。下面是一个简单的示例：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">&#123;</span>message<span class="token punctuation">&#125;</span></span><span class="token string">, </span><span class="token interpolation"><span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span></span><span class="token string">!"</span></span><span class="token punctuation">)</span><span class="token comment"># 使用位置参数调用函数</span>greet<span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span>   <span class="token comment"># 输出：Hello, Alice!</span><span class="token comment"># 使用关键字参数调用函数</span>greet<span class="token punctuation">(</span>message<span class="token operator">=</span><span class="token string">"Hi"</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"Bob"</span><span class="token punctuation">)</span>   <span class="token comment"># 输出：Hi, Bob!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>自己定义的函数可以与内置函数<strong>同名</strong>，当调用此函数时会先调用自己定义的函数;</li><li><code>input()</code>函数用于从标准输入读取用户输入的<strong>字符串</strong>，并将其作为返回值返回给调用者。</li><li>在 Python 函数中，* 号可以用来接收可变数量的参数，即不确定参数的数量。传递给函数的所有参数打包成一个元组传递给该参数。</li></ul><h2 id="8-Python标准库"><a href="#8-Python标准库" class="headerlink" title="8. Python标准库"></a>8. Python标准库</h2><ul><li>time库中<code>ctime()</code>函数是生成一个时间的字符串</li><li><code>t.fd(50)</code>表示向当前方向移动50个像素长度，<code>t.left(60)</code>表示向左旋转60度</li><li><code>time</code>库中<code>perf_counter()</code>函数一般用于计时; <code>sleep()</code>函数用于暂停程序执行; <code>strftime()</code>和<code>strptime()</code>都是用于显示时间。</li><li>允许的导入方式：<code>from numpy import ndarray</code></li><li><code>time.time()</code> 返回的是当前时间的时间戳，是一个浮点数，以秒为单位。</li><li>在Pthon语言中，<code>turtle</code>库没有trtlesize函数。shape(函数用于设器绘图前头的形状。<code>getscren()</code>函数返回一个TurtleScreen类的绘图对象，并开启绘画。setup函数打开一个自定义大小和位置的画布。</li></ul><h2 id="9-Python第三方库"><a href="#9-Python第三方库" class="headerlink" title="9. Python第三方库"></a>9. Python第三方库</h2><ul><li>获取数组形状：使用 <code>shape</code>属性可以获取数组的形状（即每个维度的长度）。例如，对于一个二维数组 <code>arr</code>，可以使用 <code>arr.shape</code>来获取它的形状。<code>ndim</code>:数组的维度;<code>shape</code>: 数组的形状。<code>size</code>: 数组的元素个数; <code>itemsize</code>:数组的每个元素占用的内 存大小，以字节为单位。</li><li>在Python语言中，用于数据分析的第三方库有<code>numpy</code>、<code>scipy</code>、<code>pandas</code>和<code>matplotlib</code>。<code>scrapy</code>库是网络爬虫方向的第三方库。<code>requests</code>是网络爬虫方向的第三方库</li><li>redis-p是数据存储方向的第三方库，Diango是Web开发方向的第三方库，NLTK是自然语言处理方向的第二方库;Luminoth是计算机视觉方向的第三方库。</li><li><code>Pyinstaller</code>工具没有-L参数。-D是默认值，生成dist目录;-F是指在dit文件夹中只生成独立的打包文件;-i是指定打包程序使用的图标文件。只能处理UTF-8编码形式的Python源文件</li><li><code>PIL</code>（Python Imaging Library）是Python中用于图像处理的标准库之一。它支持各种格式的图片处理，包括打开、修改、保存等操作。使用PIL可以轻松地完成图片的缩放、剪裁、旋转、调整亮度、对比度等操作，还可以将多张图片合成一张、加水印、增加滤镜等。</li><li>Natural Language Toolkit（<code>NLTK</code>）是一个用于Python编程语言的自然语言处理工具包。它提供了一系列用于处理人类语言文本数据的库、数据集、以及一些文本处理工具和接口。</li><li><code>BeautifulSoup</code>是Python的一个库，它用于解析HTML和XML文档，可以快速的从网页中提取需要的数据。</li></ul><h2 id="00-公共基础知识"><a href="#00-公共基础知识" class="headerlink" title="00 公共基础知识"></a>00 公共基础知识</h2><ul><li>带符号的定点数中，正数的原码、反码、补码均相同，负数的反码是对该数的原码除符号位外各位取反，补码是在该数的反码的最后（即最右边）一位上加1，不管是正数还是负数，其<strong>补码的符号位取反即是偏移码</strong>。</li><li>进程控制块PCB是进程存在的<strong>惟一标志</strong>。</li><li>进程<strong>创建完成后</strong>即进入就绪状态，处于就绪状态的进程可以有多个，处于运行状态的进程当<strong>运行时间片用完后</strong>将转换为就绪状态。</li><li>一个正在运行的进程由于所申请的资源得不到满足要调用<strong>阻塞进程</strong>。</li><li>若循环队列的存储空间为(1m)，在循环队列运转起来后，如果<code>front&lt;rear</code>，则队列中的元素个数为rear-front;如果<code>front&gt;rear</code>，则队列中的元素个数为rear-front+m。</li><li>带链的栈是具有栈属性的链表。链表的存储单元是不连续的，由于是不连续的存储空间，所以指针将不会有规律地连续变化。当top=bottom=NULL时，为栈空，当tp=bottom且不等于NULL时，<strong>栈中存在一个元素</strong>，其他情况无法判断。</li><li>树是一种非线性的数据结构，由若干个节点（node）和若干条边（edge）组成。树中度的概念是指一个节点的子节点的个数。例如，一个节点有 3 个子节点，则其度为 3。一个树的度是树中所有节点中最大的度数。树的总的结点数为树中所有结点的度数<strong>之和再加1</strong>。度为0的结点：叶子结点</li><li>二叉树的三种序列：<ul><li>前序遍历：根左右</li><li>中序遍历：左根右</li><li>后序遍历：左右根</li><li>三种遍历在每个节点处都是一样的，<strong>依此类推上去</strong>。</li></ul></li><li>数据流图的作用是支持软件系统功能建模</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具技巧合集</title>
      <link href="/posts/cffa0a0a.html"/>
      <url>/posts/cffa0a0a.html</url>
      
        <content type="html"><![CDATA[<p>这一篇博文主要是记录在生活工作中用到的工具和技巧的一些说明合集，在需要的时候能够找到对应的使用说明，避免重复的检索。目前暂定为电脑和手机两大分类，遇到相关的就会进行<strong>持续更新:</strong></p><h1 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h1><h2 id="AudioRelay"><a href="#AudioRelay" class="headerlink" title="AudioRelay"></a>AudioRelay</h2><ul><li><strong>介绍：</strong>  音频软件，将电脑端的音频流传输到安卓设备。使用过，效果不错。</li><li><strong>教程：</strong> 在同一WiFi环境下，获取IP地址，一端作为服务器，一端作为播放器。<a href="https://www.xitongbuluo.com/jiaocheng/69938.html">audiorelay怎么用？audiorelay软件使用方法教程-系统部落</a></li><li><strong>网站：</strong> <a href="https://audiorelay.net/">Stream audio between your devices - AudioRelay</a><h2 id="SpaceSniffer"><a href="#SpaceSniffer" class="headerlink" title="SpaceSniffer"></a>SpaceSniffer</h2></li><li><strong>介绍：</strong> 空间检索软件，运行可以查看磁盘内不同文件的占用空间情况。</li><li><strong>教程：</strong> 在得到不同文件夹的占用情况后，可以复制占用大的文件名进行网络检索，判断其是否可以删除，以此达到减少磁盘空间占用的目的。</li><li><strong>网站：</strong> <a href="https://spacesniffer.en.softonic.com/">spacesniffer</a> ，<a href="http://www.tbtool.cn/">图吧工具箱 - 最纯净的硬件工具箱</a><h2 id="Auto-Mute"><a href="#Auto-Mute" class="headerlink" title="Auto Mute"></a>Auto Mute</h2></li><li><strong>介绍：</strong> 实现电脑在特定场景下（锁定等）自动静音。</li><li><strong>网站：</strong> <a href="https://auto-mute.com/">Auto Mute - Free software for PC and Mac</a><h2 id="Office-Tool-Plus"><a href="#Office-Tool-Plus" class="headerlink" title="Office Tool Plus"></a>Office Tool Plus</h2></li><li><strong>介绍：</strong> 安装office系列软件以及进行激活等。</li><li><strong>教程：</strong> <ul><li>1、以Office365为例，在部署界面选择Office365（企业或者家庭等都可以），64位，其它基本保持默认，选择想要安装的应用程序（基本的三件套：Word、PPT、Excel）。 2、开始部署后，等待安装完成（这个过程估计十分钟），接着进行激活操作，需要安装许可证，选择Office Mondo 2016-批量许可证，然后在KMS主机处输入主机地址（<strong>这一步尤其注意要保存设置</strong>），然后点击激活。</li><li>KMS主机有：Kms.loli.beer；kms.loli.best(端口1688)</li><li>安装前最好在工具箱进行移除Office，确保软件和许可证等都已经卸载干净。</li></ul></li><li><strong>网站：</strong> <a href="https://otp.landian.vip/zh-cn/">Office Tool Plus 官方网站 - 一键部署 Office</a><h2 id="音频解锁转换"><a href="#音频解锁转换" class="headerlink" title="音频解锁转换"></a>音频解锁转换</h2></li><li><strong>介绍</strong> ：对酷狗音乐等专属音乐文件格式进行解锁，转换成MP3文件。</li><li><strong>网站</strong>： <a href="https://demo.unlock-music.dev/">音乐解锁</a><h2 id="语音转文字"><a href="#语音转文字" class="headerlink" title="语音转文字"></a>语音转文字</h2></li><li><strong>介绍</strong>：飞书妙记，能够免费实现语音转文字，同时智能识别讲话双方。</li><li><strong>网站</strong>： <a href="https://www.feishu.cn/product/minutes">飞书妙记</a><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2></li><li><strong>介绍</strong>：图压，压缩效果不错，默认级别即可。</li><li><strong>网站</strong>： <a href="https://tuya.xinxiao.tech/">图压 - 简单易用的图片压缩软件</a><h2 id="视频转音频"><a href="#视频转音频" class="headerlink" title="视频转音频"></a>视频转音频</h2></li><li><strong>介绍</strong>：Pazera_Free_Audio_Extractor，提取方便快捷。</li><li><strong>网站</strong>：安装包链接：<a href="https://www.lanzoux.com/i4hteod">Pazera_Free_Audio_Extractor_64bit_PORTABLE.zip - 蓝奏云</a></li></ul><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python语言基本语法元素</title>
      <link href="/posts/8d216e5f.html"/>
      <url>/posts/8d216e5f.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序的格式框架"><a href="#程序的格式框架" class="headerlink" title="程序的格式框架"></a>程序的格式框架</h1><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><ul><li>python使用严格的“缩进”来表示程序逻辑</li><li>在if、else、while、for、def、try、except等保留字所在完成语句后通过英文冒号（：）结尾并在之后行行进行缩进，表明<strong>后续代码与紧邻无缩进语句的从属关系</strong>。</li><li>缩进用Tab实现，或者是多个空格（一般是4个空格）<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2></li><li>注释是代码中的辅助性文字，会被编译器或解释器略去，不被计算机执行，一般用于程序员对代码的说明；python使用‘# 单行注释’、’’’ 多行注释’’’</li></ul><p>  单行注释：‘<strong>#</strong>’符号,表示一行注释的开始，注释可以在一行的任意位置通过‘#’开始，其符号后面的一行内容中全部会被当成注释，而前面的内容依旧会被当成代码执行；</p><p>  多行注释：<strong>‘’’多行注释’’’</strong>，位于三对<u>单引号（双引号）</u>中的内容，无论是否换行，都是注释，不会被python解释器所执行；</p><h2 id="续航符"><a href="#续航符" class="headerlink" title="续航符"></a>续航符</h2><ul><li>python程序是逐行编写的，每行代码并无限制，但是从程序员的角度，单行代码太长并不方便阅读，这个时候就可以采用续航符将单行代码分割为多行表达。</li><li>python中的续航符为‘\’。续航符之后不允许再空格，也就是说续航符之后直接换行；<h1 id="语法元素的名称"><a href="#语法元素的名称" class="headerlink" title="语法元素的名称"></a>语法元素的名称</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2>变量是保存和表示数据值的一种语法元素，变量的值是可以改变的，通过赋值运算符‘=’方式被修改，python中变量可以随时命名、随时使用、随时赋值<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2></li><li>采用大小写字母、数组、下划线和汉字等字符及其组合来进行命名，但<strong>名字的首字符不能是数字</strong>，中间不能出现空格</li><li>标识符对大小写敏感，一般不采用中文来进行命名。<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2></li><li>保留字（keyword），又称关键字，指被编程语言内部定义并保留使用的标识符。</li><li><img src="https://image.haoqin.vip/2022/11/011a8cbcea71c7389e25d5926250a8b9.png" alt=""></li><li>保留字对大小写敏感<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2></li><li>表示数字或数值的数据类型成为数字类型，有3中数字类型：整数、浮点数和复数</li><li>整数类型，可正可负，表示为十进制、二进制、八进制和十六进制</li><li>浮点数类型，科学计数法： 1.23456e2<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2>字符串是字符的有序集合，可以使用一对单引号或一对双引号，或者3对双引号来创建，python字符串的索引有正向索引和反向索引之分，通过索引你可以随机访问字符串</li><li>字符串序号体系<img src="https://image.haoqin.vip/2022/11/7ce65abe206fbf4da117c0813d8a9ea9.png" alt=""></li><li>字符串索引<pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt;&quot;abc,def&quot;[1]&#39;b&#39;&gt;&gt;&gt;&quot;abc,def&quot;[-4]&#39;,&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>可以通过采用[N:M]格式获取字符串的子串，这种操作被称为<strong>切片</strong>操作。[N,M]获取字符串中从N到M <strong>（但不包括M）</strong> 的连续的子字符串。N和M都表示的是索引序号，可以混合使用正向递增和反向递减序号；<pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; a &#x3D; &#39;python&#39;&gt;&gt;&gt; a[1:3]&#39;yt&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="程序的语句元素"><a href="#程序的语句元素" class="headerlink" title="程序的语句元素"></a>程序的语句元素</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2>产生或计算新数据值的代码片段成为表达式；类似于数学中的公式，一般由数据和操作符构成；<h2 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h2></li><li>对变量进行赋值的一行代码叫赋值语句；在python中使用一个‘=’表示‘赋值’，也就是说把等号右边的表达式运算之后的结果值赋给左边的变量；</li><li>同步赋值，可以同时给多个变量赋值，还可以应用于互换变量的值<pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt;x,y &#x3D; y,x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2></li><li>python程序会经常使用到当前程序以外的已有的功能代码，这个过程叫引用，python语言使用import这个保留字引用当前程序以外的<strong>功能库(模块)</strong></li><li>引用功能库之后<code>功能库.函数名()</code>的方式调用基本功能，这种方式称为‘A.B()’方式</li><li>如何在program_count.py 文件中使用utils.py文件中的函数呢？使用import，直接导入utils模块，使用get_file_lst函数时，则需要用<code>utils.get_file_lst</code>这种方法来调用函数。</li><li>import 会将整个模块的内容全部导入，但有时，我们不需要那么多，只需要其中一个两个就可以了。于是，我们也可以这样写<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> utils <span class="token keyword">import</span> get_file_lst<span class="token keyword">def</span> <span class="token function">get_py_program_count</span><span class="token punctuation">(</span>py_path<span class="token punctuation">)</span><span class="token punctuation">:</span>    file_lst <span class="token operator">=</span> get_file_lst<span class="token punctuation">(</span>py_path<span class="token punctuation">,</span> <span class="token string">'.py'</span><span class="token punctuation">)</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> file_name <span class="token keyword">in</span> file_lst<span class="token punctuation">:</span>        count <span class="token operator">+=</span> get_program_line_count<span class="token punctuation">(</span>file_name<span class="token punctuation">)</span>    <span class="token keyword">return</span> count<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果你想全部导入，也可以写成from … import * 的形式，* 表示全部导入。这种写法和import的区别在于，import一个模块A后，调用A里的函数是必须写成<strong>A.func</strong>的形式，而from … import … 的方法，就可以不用模块去调用方法了，可以<strong>直接调用函数</strong><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2></li><li>分支语句（判断语句）是控制程序运行的一种语句，它的作用是根据判断条件选择程序执行路径。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> <span class="token operator">&lt;</span>条件判断<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token operator">&lt;</span>执行<span class="token number">1</span><span class="token operator">></span><span class="token keyword">elif</span> <span class="token operator">&lt;</span>条件判断<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token operator">&lt;</span>执行<span class="token number">2</span><span class="token operator">></span><span class="token keyword">elif</span> <span class="token operator">&lt;</span>条件判断<span class="token number">3</span><span class="token operator">></span><span class="token punctuation">:</span>    <span class="token operator">&lt;</span>执行<span class="token number">3</span><span class="token operator">></span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token operator">&lt;</span>执行<span class="token number">4</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2></li><li>Python的循环有两种，一种是for…in循环，依次把list或tuple中的每个元素迭代出来，<pre class="line-numbers language-python" data-language="python"><code class="language-python">names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Michael'</span><span class="token punctuation">,</span> <span class="token string">'Bob'</span><span class="token punctuation">,</span> <span class="token string">'Tracy'</span><span class="token punctuation">]</span><span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token comment"># 依次打印三个姓名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>n <span class="token operator">=</span> <span class="token number">99</span><span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">+</span> n    n <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基本输入-输出函数"><a href="#基本输入-输出函数" class="headerlink" title="基本输入/输出函数"></a>基本输入/输出函数</h1><h2 id="input-函数"><a href="#input-函数" class="headerlink" title="input()函数"></a>input()函数</h2></li><li>input函数是从控制台获取用户的一行输入，无论用户输入什么内容，input函数都以<strong>字符串类型</strong>返回；input函数可以包含一些提示性文字，用来提示用户；</li><li>变量 = input(“提示性文字”)<h2 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h2></li><li>eval(str)函数将去掉字符串最外侧的引号，并按照python语句方式去<strong>执行</strong>去掉引号之后的字符内容，说白了就是一个可以将内容当成python语言执行的函数</li><li>当你输入一个错误格式的python语句进去后，他会将其当成变量，并查找相关变量的值，如果没有查到，就会报错，如果查到则执行；</li><li>eval()与input()函数还可以一起联动使用<pre class="line-numbers language-python" data-language="python"><code class="language-python">abc <span class="token operator">=</span> <span class="token number">123</span>a <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token number">123</span><span class="token operator">>></span><span class="token operator">></span>value <span class="token operator">=</span> <span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入："</span><span class="token punctuation">)</span><span class="token punctuation">)</span>请输入： <span class="token number">520</span><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>value<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token number">1040</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="print-函数"><a href="#print-函数" class="headerlink" title="print()函数"></a>print()函数</h2></li><li>当print输出字符串时，字符串统一使用单引号表达，在[ ]中的字符串都使用了双引号，但是在采用print输出时，输出结果都采用了单引号；<img src="https://image.haoqin.vip/2022/11/bcb0cd6cdbc53c5964c69d1f521aa774.png" alt=""></li><li><code>print()</code>函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：<code>print()</code>会依次打印每个字符串，遇到逗号“,”会输出一个空格。</li><li>用于混合输出字符串与变量的值，其中字符串模板使用{ }表示一个槽位，每个槽位对应.format()中的一个变量；<code>print(&quot;这是&#123; &#125;，那是&#123; &#125;，最后是&#123; &#125;&quot;.format(变量1, 变量2, 变量3))</code></li><li>print()函数输出文本时默认会再最后增加一个换行，如果不希望进行换行的话，可以对print()函数的end参数进行赋值：<code>print(&quot;待输出内容&quot;, end=&#39;增加的结尾&#39;)</code></li></ul><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p> <a href="https://www.cnblogs.com/huxiaoyao/p/16517169.html">计算机二级python（第二阶段） - 狐小妖 - 博客园</a><br> <a href="http://www.coolpython.net/python_primary/python_primary_tutorial.html">python基础入门教程—基于python3版本, 免费且专业, 通俗易懂 | 酷python</a><br> <a href="https://www.liaoxuefeng.com/wiki/1016959663602400">Python教程 - 廖雪峰的官方网站</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS工作及通信机制</title>
      <link href="/posts/bf62b2d6.html"/>
      <url>/posts/bf62b2d6.html</url>
      
        <content type="html"><![CDATA[<p>ROS具有一套自己的工作流程，其文件体系依托在工作空间中，开发的流程如下图所示。<br><img src="https://image.haoqin.vip/2022/08/202208201040585.png" alt=""><br>如果是 python 代码则不需要配置编译规则。</p><h1 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h1><p><strong>工作空间</strong>（Workspace）：存放工程开发相关文件的文件夹。类似一个IDE（例如Pycharm）新建一个工程，就是一个工作空间。包含4个文件夹：</p><ul><li>src：<strong>代码空间</strong>（Source Space）：放置功能包代码</li><li>build：<strong>编译空间</strong>（Build Space）：编译过程中产生的中间文件，不用过多关注</li><li>devel：<strong>开发空间</strong>（Development Space）：放置编译生成的可执行文件、库、脚本</li><li>install：<strong>安装空间</strong>（Install Space）：存放可执行文件，与上面有一定重复<h2 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h2></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#创建工作空间指令</span><span class="token function">mkdir</span> -p ~/catkin_ws/src<span class="token builtin class-name">cd</span> ~/catkin_ws/srccatkin_init_workspace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们先创建一个src文件夹，然后进入该文件夹<br>第3行<code>catkin_init_workspace</code>意为将当前文件夹变为工作空间，使其拥有工作空间的属性<br>注：“~/”意为当前用户名目录；“-p”意为递归创建目录，即直接创建多级目录。<br>src文件夹即代码空间，不能自行用别的名称代替</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#编译空的工作空间</span><span class="token builtin class-name">cd</span> ~/catkin_ws/  catkin_make <span class="token comment">#将src里的源码进行了编译</span><span class="token comment">#生成了build和devel两个新文件夹，devel存放了编译完成的内容</span><span class="token comment">#设置环境变量</span><span class="token builtin class-name">source</span> devel/setup.bash<span class="token comment">#如果要生成install文件夹</span>catkin_make <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了不每次打开终端都设置环境变量（即都执行一遍 <code>$ source devel/setup.bash</code>），可以把这句话添加到系统环境变量<code>.bashrc</code> 中。</p><ol><li>通过 <code>$ sudo vim ~/.bashrc</code> 打开<code>.bashrc</code> 文件。</li><li>在文件最后添加：<code>source ~/catkin_ws/devel/setup.bash</code></li><li>保存，关闭。<h2 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h2></li></ol><ul><li><strong>功能包</strong>是放置ROS源码的最小单元。<br><img src="https://image.haoqin.vip/2022/08/202208201111649.png" alt=""></li></ul><p>1, <strong>package</strong>文件夹为功能包，也就是我们开发ROS工程主要编辑的地方<br>2, <strong>package</strong>文件夹下<strong>package.xml</strong>文件主要是描述整个功能包的属性。<br>3, <strong>package</strong>文件夹下<strong>CMakeLists.txt</strong>文件主要作用是描述整个功能包的编译规则，依赖库等等。<br>4, <strong>package</strong>文件夹下的<strong>src</strong>文件夹为功能包源文件所在。<br>5, <strong>package</strong>文件夹下的<strong>include</strong>文件夹为功能包源文件的头文件所在。<br>6, <strong>package</strong>文件夹下的<strong>script</strong>文件夹为python脚本和bash脚本所在，即无需编译即可运行的文件。<br>7, <strong>package</strong>文件夹下的<strong>launch</strong>文件夹为launch文件所在<br>8, <strong>package</strong>文件夹下的<strong>msg</strong>文件夹为msg文件所在<br>9, <strong>package</strong>文件夹下的<strong>srv</strong>文件夹为srv文件所在<br>9, <strong>package</strong>文件夹下的<strong>action</strong>文件夹为action文件所在</p><ul><li>上面我们创建了一个空的工作空间，src文件夹里面没写东西，现在我们创建一个自己的功能包。  注意同一工作空间下，不允许存在同名功能包；不同工作空间下，允许存在同名功能包。<br>指令格式：<code>catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</code><br><code>&lt;package_name&gt;</code>为包名<br><code>[depend]</code>为依赖，即指明编译的时候需要ROS中的其他功能包，如需要调用python、C++库，就要指明rospy、roscpp。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/catkin_ws/src <span class="token comment"># 创建一个名叫learning_communication的功能包  </span><span class="token comment"># 这个功能包实现的接口有python接口，C++接口，标准定义的消息与服务接口</span>catkin_create_pkg learning_communication rospy roscpp std_msgs std_srvs<span class="token comment"># 编译功能包</span><span class="token builtin class-name">cd</span> ~/catkin_wscatkin_make<span class="token builtin class-name">source</span> ~/catkin_ws/devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Topic-通信机制"><a href="#Topic-通信机制" class="headerlink" title="Topic 通信机制"></a>Topic 通信机制</h1><img src="https://image.haoqin.vip/2022/08/202208202024525.png" alt=""></li></ul><h2 id="发布者Publisher"><a href="#发布者Publisher" class="headerlink" title="发布者Publisher"></a>发布者Publisher</h2><ul><li>初始化ROS节点</li><li>向ROS Master注册节点信息，包括发布的话题名和话题中的消息类型</li><li>创建消息数据</li><li>按照一定的频率循环发布消息<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**   * 该例程将发布chatter话题，消息类型String   *&#x2F;    &#x2F;&#x2F; 字符串的流的数据转换  #include &lt;sstream&gt;  &#x2F;&#x2F; 包含ros头文件，一般都会写  #include &quot;ros&#x2F;ros.h&quot;  &#x2F;&#x2F; 后面会用到ROS中string的消息类型  #include &quot;std_msgs&#x2F;String.h&quot;    int main(int argc, char **argv)  &#123;      &#x2F;&#x2F; ROS节点初始化，声明节点名，这个名字不能和其他节点重名      ros::init(argc, argv, &quot;string_publisher&quot;);        &#x2F;&#x2F; 创建节点句柄，完成ROS核心资源的管理。      &#x2F;&#x2F; 在节点初始化和关闭一节中,使用句柄管理节点的内部引用,使启动和关闭一个节点变得简单。        ros::NodeHandle n;        &#x2F;&#x2F; 创建一个Publisher，发布名为chatter的topic，消息类型为std_msgs::String。      &#x2F;&#x2F; 在ros::Publisher类下实例化一个chatter_pub对象。      &#x2F;&#x2F; 1000表示缓冲区大小，超过1000会把时间戳最老的删除掉。      &#x2F;&#x2F; advertise( ) 返回一个 Publisher 对象。 通过调用对象的 publish( )函数可以在这个topic上发布 message。      ros::Publisher chatter_pub &#x3D; n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000);        &#x2F;&#x2F; 设置循环的频率      &#x2F;&#x2F; loop_rate()是ros::Rate类可定制频率的函数，接受一个int型参数，通过调用主函数末尾的上来sleep（）函数，将该参数置为发布频率。      ros::Rate loop_rate(10);        int count &#x3D; 0;            &#x2F;&#x2F; ros::ok()会设置一个SIGINT监听，函数返回True，仅当以下四种情况发生时，该函数返回False：  　　 &#x2F;&#x2F; 1. SIGINT被触发（Ctrl+c）  　　 &#x2F;&#x2F; 2.被另一同名节点踢出  　　 &#x2F;&#x2F; 3.函数ros::shutdown（）被程序另一部分调用  　　 &#x2F;&#x2F; 4.程序所有句柄被销毁      while (ros::ok())      &#123;          &#x2F;&#x2F; 初始化std_msgs::String类型的消息          std_msgs::String msg;          &#x2F;&#x2F; 初始化字符串流          std::stringstream ss;          &#x2F;&#x2F; 把信息放到字节流里          ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count;          &#x2F;&#x2F; msg中的data是存储信息的，直接赋值          msg.data &#x3D; ss.str();            &#x2F;&#x2F; 发布消息          &#x2F;&#x2F; 输出一个字符串变量,ROS_INFO其实就是printf          &#x2F;&#x2F; c_str()：将C++的string转化为C的字符串数组，c_str()生成一个const char *指针，指向字符串的首地址。          ROS_INFO(&quot;%s&quot;, msg.data.c_str());          &#x2F;&#x2F; 通过调用对象的 publish( )函数发布数据          chatter_pub.publish(msg);            &#x2F;&#x2F; 按照循环频率延时          loop_rate.sleep();          ++count;      &#125;        return 0;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>这个cpp文件创建在src文件夹下,有了源码之后需要在CMakeLists.txt中添加<strong>编译规则：</strong><pre class="line-numbers language-CMAKE" data-language="CMAKE"><code class="language-CMAKE"># 设置需要编译的代码和生成的可执行文件  # 让string_publish.cpp这个cpp文件编译生成string_publish  add_executable(string_publisher src&#x2F;string_publisher.cpp)  # 设置string_publisher与库catkin_LIBRARIES的连接  target_link_libraries(string_publisher $&#123;catkin_LIBRARIES&#125;)# 后面的Subscriber也是如此add_executable(string_subscriber src&#x2F;string_subscriber.cpp)  target_link_libraries(string_subscriber $&#123;catkin_LIBRARIES&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>回到工作空间目录，执行<strong>编译</strong>.<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> ~/catkin_ws  $ catkin_make    <span class="token comment"># 配置系统环境变量后这步可以省略  </span>$ <span class="token builtin class-name">source</span> devel/setup.bash    $ roscore  $ rosrun learning_communication string_publisher  $ rosrun learning_communication string_subscriber<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><strong>python</strong>的源代码，放在功能包文件夹下的scripts目录下的。<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span><span class="token keyword">import</span> rospy<span class="token keyword">from</span> geometry_msgs<span class="token punctuation">.</span>msg <span class="token keyword">import</span> Twist<span class="token keyword">def</span> <span class="token function">velocity_publisher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># ROS节点初始化</span>    rospy<span class="token punctuation">.</span>init_node<span class="token punctuation">(</span><span class="token string">'velocity_publisher'</span><span class="token punctuation">,</span> anonymous<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment"># 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span>    turtle_vel_pub <span class="token operator">=</span> rospy<span class="token punctuation">.</span>Publisher<span class="token punctuation">(</span><span class="token string">'/turtle1/cmd_vel'</span><span class="token punctuation">,</span> Twist<span class="token punctuation">,</span> queue_size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token comment">#设置循环的频率</span>    rate <span class="token operator">=</span> rospy<span class="token punctuation">.</span>Rate<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>     <span class="token keyword">while</span> <span class="token keyword">not</span> rospy<span class="token punctuation">.</span>is_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 初始化geometry_msgs::Twist类型的消息</span>        vel_msg <span class="token operator">=</span> Twist<span class="token punctuation">(</span><span class="token punctuation">)</span>        vel_msg<span class="token punctuation">.</span>linear<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0.5</span>        vel_msg<span class="token punctuation">.</span>angular<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0.2</span><span class="token comment"># 发布消息</span>        turtle_vel_pub<span class="token punctuation">.</span>publish<span class="token punctuation">(</span>vel_msg<span class="token punctuation">)</span>    rospy<span class="token punctuation">.</span>loginfo<span class="token punctuation">(</span><span class="token string">"Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]"</span><span class="token punctuation">,</span> vel_msg<span class="token punctuation">.</span>linear<span class="token punctuation">.</span>x<span class="token punctuation">,</span> vel_msg<span class="token punctuation">.</span>angular<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token comment"># 按照循环频率延时</span>        rate<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        velocity_publisher<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> rospy<span class="token punctuation">.</span>ROSInterruptException<span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>需要打开py文件的<strong>可执行权限</strong>。</p><h2 id="订阅者Subscriber"><a href="#订阅者Subscriber" class="headerlink" title="订阅者Subscriber"></a>订阅者Subscriber</h2><ul><li>初始化ROS节点</li><li>订阅需要的话题</li><li>循环等待话题消息，接收到消息后进入回调函数</li><li>在回调函数中完成消息处理<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;**   * 该例程将订阅chatter话题，消息类型String   *&#x2F;     &#x2F;&#x2F; ros头文件  #include &quot;ros&#x2F;ros.h&quot;  &#x2F;&#x2F; 后面会用到ROS中string的消息类型  #include &quot;std_msgs&#x2F;String.h&quot;    &#x2F;&#x2F; 接收到订阅的消息后，会进入消息回调函数  &#x2F;&#x2F; 定义一个指针常量的引用msg  void chatterCallback(const std_msgs::String::ConstPtr&amp; msg)  &#123;      &#x2F;&#x2F; 将接收到的消息打印出来      ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str());  &#125;    int main(int argc, char **argv)  &#123;      &#x2F;&#x2F; 初始化ROS节点      ros::init(argc, argv, &quot;string_subscriber&quot;);        &#x2F;&#x2F; 创建节点句柄      ros::NodeHandle n;        &#x2F;&#x2F; 创建一个Subscriber，订阅名为chatter的topic，注册回调函数chatterCallback      ros::Subscriber sub &#x3D; n.subscribe(&quot;chatter&quot;, 1000, chatterCallback);        &#x2F;&#x2F; 循环等待回调函数      &#x2F;&#x2F; spin本身的循环条件就是ros::ok()      ros::spin();        return 0;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>配置<strong>编译规则和环境变量</strong>，进行<strong>编译</strong>。</li></ul><ul><li>python版本</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span><span class="token keyword">import</span> rospy<span class="token keyword">from</span> turtlesim<span class="token punctuation">.</span>msg <span class="token keyword">import</span> Pose<span class="token keyword">def</span> <span class="token function">poseCallback</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>    rospy<span class="token punctuation">.</span>loginfo<span class="token punctuation">(</span><span class="token string">"Turtle pose: x:%0.6f, y:%0.6f"</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span>x<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">pose_subscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># ROS节点初始化</span>    rospy<span class="token punctuation">.</span>init_node<span class="token punctuation">(</span><span class="token string">'pose_subscriber'</span><span class="token punctuation">,</span> anonymous<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment"># 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span>    rospy<span class="token punctuation">.</span>Subscriber<span class="token punctuation">(</span><span class="token string">"/turtle1/pose"</span><span class="token punctuation">,</span> Pose<span class="token punctuation">,</span> poseCallback<span class="token punctuation">)</span><span class="token comment"># 循环等待回调函数</span>    rospy<span class="token punctuation">.</span>spin<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    pose_subscriber<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>我们通过自定义msg文件来自定义话题消息。在功能包根目录下新建文件夹msg，并<code>touch Person.msg</code>,文件内容</p><pre class="line-numbers language-msg" data-language="msg"><code class="language-msg">string name  uint8 age  uint8 sex    uint8 unknown &#x3D; 0  uint8 male    &#x3D; 1  uint8 female  &#x3D; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在package.xml中添加功能包依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">></span></span>message_generation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">></span></span>message_runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>build_depend为编译依赖，这里依赖的是一个会动态产生message的功能包<br>exer_depend为执行依赖，这里依赖的是一个动态runtime运行的功能包</p><p>在CMakeLists.txt中添加编译选项：</p><ol><li><code>find_package(…… message_generation)</code></li><li>添加：<code>add_message_files(FILES PersonMsg.msg)</code> 和 <code>generate_messages(DEPENDENCIES std_msgs)</code>（前一句话是编译生成头文件，后一句话是调用了 ros 的标准数据类型）</li><li><code>catkin_package(…… message_runtime)</code><br>回到根目录，编译<code>catkin_make</code>,编译完成后，我们可以在devel/include/learning_topic/ 下找到这个C++的头文件</li></ol><h1 id="Service通信机制"><a href="#Service通信机制" class="headerlink" title="Service通信机制"></a>Service通信机制</h1><p><img src="https://image.haoqin.vip/2022/08/202208202123416.png" alt=""><br>详细步骤懒得摘录了，跟Topic机制有一定的<strong>类似</strong>。直接见<a href="https://hljmssjg.github.io/2022/01/01/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003/#4-1-%E8%AF%B7%E6%B1%82-%E6%9C%8D%E5%8A%A1-Hello-worl">ROS学习笔记 03 ROS通信编程 | 孙健耕的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P450无人机</title>
      <link href="/posts/f59f5b40.html"/>
      <url>/posts/f59f5b40.html</url>
      
        <content type="html"><![CDATA[<p>P450是阿木实验室出品的无人机。其官方简介为：Prometheus450（简称P450）是一款专为科研工作者及无人机开发者设计的无人机实验平台，适用于无人机专业应用研究和开发。本开发平台基于Prometheus开源项目，提供丰富的demo例程，涵盖控制模块、slam模块、规划模块以及目标检测模块等多个无人机及机器视觉相关研究方向。</p><p>常用的文档：<br><a href="https://wiki.amovlab.com/public/prometheuswiki/P450%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html">P450使用手册 - P系列无人机文档</a><br><a href="https://github.com/amov-lab/Prometheus/wiki">Home · amov-lab/Prometheus Wiki · GitHub</a><br><a href="https://wiki.amovlab.com/public/prometheus-wiki/">Prometheus-自主无人机开源项目 - Prometheus使用手册</a><br><a href="https://docs.px4.io/master/zh/">PX4 自动驾驶用户指南</a></p><h1 id="软硬件词汇"><a href="#软硬件词汇" class="headerlink" title="软硬件词汇"></a>软硬件词汇</h1><ul><li>Prometheus：无人机开源项目，开源仿真代码以及基础机载飞行代码</li><li>QGroundControl(QGC)：地面站，连接到飞机，监控到飞机本身的状态</li><li>Nomachine：远程桌面，用作远程连接到板载计算机</li><li>PX4:专业级飞控</li><li>Pixhawk：硬件平台，PX4固件对应硬件</li><li>Mavros：mavlink+ros。mavros是PX4官方提供的一个运行于ROS下收发<strong>mavlink消息</strong>的工具，利用mavros可以发送mavlink消息给飞控（可以控制飞机），并且可以从飞控中接受数据（例如：飞控的位置速度 IMU数据等等）</li><li>Flight Control Unit(FCU)：飞行控制单元</li></ul><h1 id="软硬件框架"><a href="#软硬件框架" class="headerlink" title="软硬件框架"></a>软硬件框架</h1><h2 id="P450硬件框架"><a href="#P450硬件框架" class="headerlink" title="P450硬件框架"></a><strong>P450硬件框架</strong></h2><p><img src="https://s-gz-3816-tuchuang.oss.dogecdn.com/2022/05/202205301204416.png" alt=""><br><strong>T265双目相机</strong>：采用优化后的V-SLAM算法<br><strong>单目相机</strong>：200w像素，OpenCV图像识别二维码引导降落，基于OpenCV的椭圆、二维码识别及追踪<br><strong>D435i深度相机</strong>：避障，物体检测和识别，大场景和快速移动跟踪<br><strong>激光雷达</strong>：测量半径40m</p><h2 id="Prometheus软件框架"><a href="#Prometheus软件框架" class="headerlink" title="Prometheus软件框架"></a><strong>Prometheus软件框架</strong></h2><p><img src="https://s-gz-3816-tuchuang.oss.dogecdn.com/2022/05/202205301211397.png" alt=""><br><img src="https://image.haoqin.vip/2023/04/879dac9d07bcd7bde1a8de13c35e1aa6.png" alt="image.png"></p><h1 id="遥控器模式"><a href="#遥控器模式" class="headerlink" title="遥控器模式"></a>遥控器模式</h1><ul><li>定点模式：该模式下横滚和俯仰摇杆控制机体的前后左右方向相对于地面的<strong>加速度</strong>（类似于车的油门踏板），油门控制上升下降的速度。 当摇杆释放/居中时，机体将主动制动，保持水平，并<strong>锁定到 3D 空间中的位置</strong> — 补偿风和其他力。</li><li>定高模式：滚转和俯仰杆控制机体在左右和前后方向上的运动（相对于机体的“前方”），偏航杆控制水平面上的旋转速度，油门控制上升 -下降的速度。当杆被释放/回中时，机体将恢复水平并保持当前的高度</li><li>自稳模式：飞控会让飞行器只有保持姿态是稳定的。位置不确定，需要双手操控，保持重力和升力平衡。<u>新手不适宜操作</u>。</li><li>遥控器左下上锁，右下解锁（左边的操作杆）</li></ul><h1 id="电池管理"><a href="#电池管理" class="headerlink" title="电池管理"></a>电池管理</h1><ul><li>上限是4.2V，对4S电池来说上限是16.8V</li><li>电池不能过充过放，使用范围应介于14.4到16.8V之间，在长期未使用的时候要让电池单电芯保持在3.85左右适宜。</li></ul><h1 id="功率监控"><a href="#功率监控" class="headerlink" title="功率监控"></a>功率监控</h1><ul><li>PM接口对应pixhawk4的power module接口</li><li>polybro的px4飞控的电源模块接口是GH1.25，CUAV家的px4飞控的电源模块接口是DF1.3，模块上红色对应5V</li></ul>]]></content>
      
      
      <categories>
          
          <category> UAV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> P450 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS概念及命令行工具</title>
      <link href="/posts/67892806.html"/>
      <url>/posts/67892806.html</url>
      
        <content type="html"><![CDATA[<p><strong>ROS：Robot Operating System</strong>，机器人操作系统。ROS是一种分布式机器人操作系统，依赖于linux（一般支持的linux系统有ubuntu系列与debian系列），由斯坦福发布，目前，很多机器人的研究都是基于它。在古月居的定义理解中，ROS = 通信机制 + 开发工具 + 应用功能 + 生态系统。<br>从网上教程数量角度和无人机仿真项目Prometheus的应用角度出发，我学习使用的是<strong>Ubuntu 18.04</strong>长期支持版本，学习教程主要是根据古月居的《ROS入门21讲》。ROS2据说支持windows系统，并未进行尝试。</p><h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><h2 id="节点（Node）–-执行单元"><a href="#节点（Node）–-执行单元" class="headerlink" title="节点（Node）– 执行单元"></a><strong>节点（Node）</strong>– 执行单元</h2><ul><li>执行具体任务的进程、独立运行的可执行文件；</li><li>不同节点可使用不同的编程语言（c++和python），可分布式运行在不同的主机；</li><li>节点在系统中的名称必须是唯一的。</li></ul><h2 id="节点管理器（ROS-Master）–-控制中心"><a href="#节点管理器（ROS-Master）–-控制中心" class="headerlink" title="节点管理器（ROS Master）– 控制中心"></a><strong>节点管理器（ROS Master）</strong>– 控制中心</h2><ul><li>为节点提供名命和注册服务；</li><li>跟踪和记录话题 / 服务通信，辅助节点相互查找、建立连接；</li><li>提供参数服务器，节点使用此服务器存储和检索运行时的参数</li><li><img src="https://image.haoqin.vip/2022/08/202208131152785.png" alt=""></li></ul><h1 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h1><h2 id="话题（Topic）–-异步通信机制"><a href="#话题（Topic）–-异步通信机制" class="headerlink" title="话题（Topic）– 异步通信机制"></a>话题（Topic）– 异步通信机制</h2><ul><li>节点间用来传输数据的重要总线；</li><li>使用发布 / 订阅模型，数据由<strong>发布者传输到订阅者</strong>，同一个话题的订阅者或发布者可以不唯一。</li><li>消息（Message）：定义数据的类型，具有一定的数据结构定义。使用编程语言无关的 ==.msg== 文件定义，编译过程中生成对应的代码文件。<h2 id="服务-Service-–-同步通信机制"><a href="#服务-Service-–-同步通信机制" class="headerlink" title="服务 (Service) – 同步通信机制"></a>服务 (Service) – 同步通信机制</h2></li><li>使用<strong>客户端 / 服务器</strong>（C/S）模型，客户端发送请求数据，服务器完成处理后返回应答数据；</li><li>使用编程语言无关的 ==.srv==  文件定义请求和应答数据，编译过程中生成对应的代码文件。</li></ul><p><img src="https://image.haoqin.vip/2022/08/202208131207217.png" alt=""></p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p><img src="https://image.haoqin.vip/2022/08/202208131559632.png" alt=""></p><h1 id="ROS命令行"><a href="#ROS命令行" class="headerlink" title="ROS命令行"></a>ROS命令行</h1><p>在ROS命令行基本操作学习中，以小海龟程序作为示例进行学习。</p><h2 id="运行小海龟程序"><a href="#运行小海龟程序" class="headerlink" title="运行小海龟程序"></a>运行小海龟程序</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 用来启动ros核心，也就是ros master节点。  </span>roscore    <span class="token comment"># rosrun表示运行一个节点  </span><span class="token comment"># turtlesim表示功能包名为turtlesim，海龟仿真器  </span><span class="token comment"># turtlesim_node表示turtlesim包下的turtlesim_node节点  </span>rosrun turtlesim turtlesim_node    <span class="token comment"># rosrun表示运行一个节点  </span><span class="token comment"># turtlesim表示功能包名为turtlesim，海龟仿真器  </span><span class="token comment"># turtlesim_node表示turtlesim包下的turtle_teleop_key节点  </span><span class="token comment"># 键盘控制  </span>rosrun turtlesim turtle_teleop_key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rqt-graph"><a href="#rqt-graph" class="headerlink" title="rqt_graph"></a>rqt_graph</h2><p>ROS的可视化工具<code>rqt_graph</code>,可以清晰的了解系统节点间通信的部分信息。<br><img src="https://image.haoqin.vip/2022/08/202208131618892.png" alt=""><br><code>teleop_turtle</code>节点（键盘控制节点）通过<code>cmd_vel</code>（topic）向<code>turtlesim</code>节点（海龟仿真器节点）发出消息，使得小海龟移动。<br><img src="https://image.haoqin.vip/2022/08/202208131619004.png" alt=""><br><code>/rosout</code> 是 ros master 启动后默认启动的一个节点，会保存所有结点的日志信息。</p><h2 id="rqt-plot"><a href="#rqt-plot" class="headerlink" title="rqt_plot"></a>rqt_plot</h2><p>左上角添加 topic，就可以实时打印某一话题里的数据内容。<br><img src="https://image.haoqin.vip/2022/08/202208131651799.png" alt=""></p><h2 id="rosnode"><a href="#rosnode" class="headerlink" title="rosnode"></a>rosnode</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 打印所有的节点  </span>rosnode list  <span class="token comment"># rosnode info /节点名</span><span class="token comment"># 打印/turtlesim节点信息，如发布的话题，订阅的话题和服务等  </span>rosnode info /turtlesim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rostopic"><a href="#rostopic" class="headerlink" title="rostopic"></a>rostopic</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 显示topic列表</span>rostopic list<span class="token comment"># 例如，结点/turtlesim正在发布海龟1的位置信息/turtle1/pose（这个是话题）  </span><span class="token comment"># echo是打印某一个话题里的数据内容  </span><span class="token comment"># 打印海龟1的姿势信息  </span><span class="token comment"># 平移单位是米，角度的单位是弧度  </span>rostopic <span class="token builtin class-name">echo</span> /turtle1/pose    <span class="token comment"># pub 表示publish  </span><span class="token comment"># 格式：rostopic pub (参数) 话题名 消息数据结构 “具体数据”</span><span class="token comment"># /turtle1/cmd_vel是topic名，表示海龟1的速度指令  </span><span class="token comment"># geometry_msgs/Twist是message名，表示线速度和角速度（机器人学中的twist）  </span><span class="token comment"># 键盘的输入的优先级高一些  </span>rostopic pub /turtle1/cmd_vel geometry_msgs/Twist +Tab键  rostopic pub -r <span class="token number">10</span> /turtle1/cmd_vel geometry_msgs/Twist +Tab键rostopic pub /turtle1/cmd_vel geometry_msgs/Twist <span class="token string">"linear:  x: 1.0  y: 0.0  z: 0.0angular:  x: 0.0  y: 0.0  z: 0.0"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rosmsg"><a href="#rosmsg" class="headerlink" title="rosmsg"></a>rosmsg</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 上例我们使用了**消息数据结构**定义了一个消息传给topic，我们可以查看有哪些消息数据结构</span><span class="token comment"># 可以看到geometry_msgs/Twist数据结构的内容</span>rosmag show geometry_msgs/Twist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="rosservice"><a href="#rosservice" class="headerlink" title="rosservice"></a>rosservice</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看服务列表</span>rosservice list<span class="token comment"># 在服务列表中，有个/spawn服务，可以产生一只新的海龟</span><span class="token comment"># 格式：`rosservice call (参数) 服务名 “具体数据”`</span>rosservice call /spawn +tab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 话题记录和重现</span><span class="token comment"># 格式：rosbag record -a -O 文件名 。保存在主目录</span>rosbag record -a -O cmd_record<span class="token comment"># 关闭所有打开的ros节点，重新开启roscore，开启海龟节点rosrun turtlesim turtlesim_node</span><span class="token comment"># 复现之前的运动</span>rosbag play cmd_record.bag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论及数理统计的基本概念</title>
      <link href="/posts/53e3ff53.html"/>
      <url>/posts/53e3ff53.html</url>
      
        <content type="html"><![CDATA[<h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><ul><li>样本点$\omega$的全体结果构成的集合成为样本空间，记为$\Omega$,即$\Omega=\lbrace \omega \rbrace$.</li><li>随机变量定义：在样本空间$\Omega$上的实值函数$X=X(\omega)$,$\omega\in \Omega$，称$X(\omega)$为随机变量，简记$X$</li><li>分布函数定义：对于任意实数x，记函数$F(x)={X\leq x},-\infty&lt;x&lt;+\infty$，称$F(x)$为随机变量$X$的分布函数</li><li>离散型随机变量：设离散型随机变量X的可能取值是$x_1,x_2,\cdots,x_n,\cdots$，$X$取各可能值的概率为:$$P{X=x_k}=p_k,k=1,2,\cdots$$</li><li>随机型随机变量：如果对随机变量$X$的分布函数$F(x)$，存在一个非负可积函数$f(x)$，使得对任意实数$x$，都有$$F\left ( x \right ) =\int_{-\infty}^{x} f\left ( t \right ) dt,-\infty &lt; x&lt;+\infty$$称$X$为连续型随机变量，函数$f(x)$为$X$的概率密度</li></ul><h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><ul><li><strong>定义</strong>：设X是随机变量，如果数学期望$E{[X-E(x)]^2}E{[X−E(x)]2}$存在，则称之为X的方差，记作D(X)，即  $$D(X)=E{[X-E(X)]^2}D(X)=E{[X−E(X)]^2}$$</li><li>方差计算公式：$D(X)=E(X^2)−[E(X)]^2$</li><li>设X是随机变量，a和b是常数，则有  $D(aX+b)=a^2D(X)$</li><li>设随机变量X和Y相互独立，则有  $D(X\pm Y)=D(X)+D(Y)$</li></ul><h2 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h2><p>$X\sim N(\mu,\sigma^2)$，其分布函数为  $$F(x)=\frac{1}{\sqrt{2\pi}\sigma}\int^x_{-\infty}e^{-\frac{(t-\mu)^2}{2\sigma^2}}dt$$</p><h1 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h1><h2 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h2><p>如果$X_1,X_2,\cdots,X_n$相互独立且都与总体X同分布，则称$X_1,X_2,\cdots,X_n$为来自总体的简单随机样本，简称为<u>样本</u>。$n$为样本容量，样本的具体观测值$x_1,x_2,\cdots,x_n$称为<u>样本值</u>，或称总体$X$的$n$个独立观测值</p><h2 id="数字特征"><a href="#数字特征" class="headerlink" title="数字特征"></a>数字特征</h2><p>设$X_1,X_2,\cdots,X_n$是来自总体X的样本，则称</p><ol><li>样本均值 $\bar{X}=\frac{1}{n}\sum\limits^n_{i=1}X_i$</li><li>样本方差 $S^2=\frac{1}{n-1}\sum\limits^n_{i=1}(X_i-\bar{X})^2$（有些书认为这个是修正样本方差）<br>样本标准差 $S=\sqrt{\frac{1}{n-1}\sum\limits^n_{i=1}(X_i-\bar{X})^2}$</li><li>样本k阶原点距 $A_k=\frac{1}{n}\sum\limits^n_{i=1}X^k_i,k=1,2,A_1=\bar{X}$</li><li>样本k阶中心距 $B_k=\frac{1}{n}\sum\limits^n_{i=1}(X_i-\bar{X})^k,k=1,2,B_2=\frac{n-1}{n}S^2\neq S^2$<h2 id="chi-2-分布"><a href="#chi-2-分布" class="headerlink" title="$\chi^2$分布"></a>$\chi^2$分布</h2>设随机变量$X_1,X_2,\cdots,X_n$相互独立且均服从标准正态分布$N(0,1)$，则称随机变量$\chi^2=X^2_1+X^2_2+\cdots+X^2_n$服从自由度为$n$的$\chi^2$分布，记作$\chi^2\sim\chi^2(n)$.性质有：</li><li>设$\chi^2\sim\chi^2(n)$，对给定的$a(0&lt;a&lt;1)$，称满足条件  $$P{\chi^2&gt;\chi^2_\alpha(n)}=\int^{+\infty}_{\chi^2_\alpha(n)}f(x)dx=\alpha$$的点$\chi^2_\alpha(n)$为$\chi^2(n)$分布上$\alpha$和$n$，$\chi^2_\alpha(n)$通常通过查表求得</li><li>设$\chi^2\sim\chi^2(n)$，则$E(\chi^2)=n,D(\chi^2)=2n$</li><li>设$\chi^2_1\sim\chi^2(n_1),\chi^2_2\sim\chi^2(n_2)$，且$\chi^2_1$和$\chi^2_2$相互独立，则$\chi^2_1+\chi^2_2\sim\chi^2(n_1+n_2)$<h2 id="t分布"><a href="#t分布" class="headerlink" title="t分布"></a>t分布</h2>设随机变量X和Y相互独立，$且X\sim N(0,1),Y\sim \chi^2(n)$，则称随机变量$$T=\frac{X}{\sqrt{Y/n}}$$服从自由度为n的t分布，记作$T\sim t(n)$</li></ol><ul><li>t分布的概率密度f(x)是偶函数，即f(x)=f(-x)，且当n充分大时，t(n)分布近似于N(0,1)分布 <h2 id="F分布"><a href="#F分布" class="headerlink" title="F分布"></a>F分布</h2>设随机变量X和Y相互独立，且$X\sim \chi^2(n_1),Y\sim\chi^2(n_2)$，则称随机变量  $$F=\frac{X/n_1}{Y/n_2}$$服从自由度为$(n_1,n_2)$的F分布，记作$F\sim F(n_1,n_2)$，其中$n_1$和$n_2$分别称为第一自由度和第二自由度<br>如果$F\sim F(n_1,n_2)$，则$\frac{1}{F}\sim F(n_2,n_1)$，且有  $$F_{1-\alpha}(n_1,n_2)=\frac{1}{F_\alpha(n_2,n_1)}$$<h2 id="正态分布抽样"><a href="#正态分布抽样" class="headerlink" title="正态分布抽样"></a>正态分布抽样</h2>设总体$X\sim N(\mu,\sigma^2),X_1,X_2,\cdots,X_n$是来自总体的样本，样本均值为$\bar{X}$，样本方差为$S^2$ ，则有：</li></ul><ol><li>$\bar{X}\sim N(\mu,\frac{\sigma^2}{n}),U=\frac{\bar{X}-\mu}{\sigma/\sqrt{n}}\sim N(0,1)$</li><li>$\bar{X}$与$S^2$相互独立，且$\chi^2=\frac{(n-1)^2S^2}{\sigma^2}\sim \chi^2(n-1)$</li><li>$T=\frac{\bar{X}-\mu}{S/\sqrt{n}}\sim t(n-1)$</li><li>$\chi^2=\frac{1}{\sigma^2}\sum\limits^n_{i=1}(X_i-\mu)^2\sim \chi^2(n)$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人机实操基本操作</title>
      <link href="/posts/997c23ab.html"/>
      <url>/posts/997c23ab.html</url>
      
        <content type="html"><![CDATA[<p>本文主要是根据21年在成都进行P450的实操培训文稿组织而成的，主要是进行<strong>定点飞行，指点飞行，圆框跟踪，室内避障</strong>这四个基本模块的操作。</p><h1 id="实操步骤"><a href="#实操步骤" class="headerlink" title="实操步骤"></a>实操步骤</h1><h2 id="定点飞行"><a href="#定点飞行" class="headerlink" title="定点飞行"></a>定点飞行</h2><p>地面站qcg连接飞机（连接wifi，添加通讯），nomachine连接板载计算机（ip地址可以根据查询电脑ip地址来判断），终端输入启动脚本，检查飞机各项数据（手动移动无人机的位置，查看终端无人机的位置数据是否有对应的变化）。</p><p>遥控器定点飞行，遥控器swc开关拨到中间挡，进入定点模式，左手遥控杆向右下方解锁，左手摇杆前后控制油门，左右控制航向；右手摇杆前后控制前后飞行，左右控制左右飞行。降落时，左手摇杆向后，油门慢慢降低，飞机降落进入怠速，上锁。（紧急关闭或者怠速油门依旧最下，切换到自稳模式上锁）,最后全部杆都应拨上。</p><h2 id="指点飞行"><a href="#指点飞行" class="headerlink" title="指点飞行"></a>指点飞行</h2><p>   终端启动基本vio脚本，检查飞机各项数据，再启动控制脚本，选择控制方式，一般为命令输入控制方式0。输入1，输出起飞指令，遥控器在定点模式（<strong>swc杆拨到中间</strong>）下解锁，然后切换到offboard模式（<strong>swd杆拨下</strong>），飞机起飞。</p><p>   输入4，进入move模式，选择子模式，常用XYZ—POS空间位置控制；选择坐标系，有惯性坐标系和机体坐标系，然后输入xyz和航向角的信息，飞机到达指定位置。</p><p>   降落时，操控遥控器退出offboard模式，油门慢慢降低，飞机降落进入怠速，上锁。</p><h2 id="圆框跟踪"><a href="#圆框跟踪" class="headerlink" title="圆框跟踪"></a>圆框跟踪</h2><p>   终端启动基本vio脚本，检查飞机各项数据，再启动跟踪脚本。调整单目摄像头向正前方，新的终端内输入指令显示图像检测内容。控制终端输入1起飞指令。</p><p>   遥控器在定点模式下解锁，然后切换到offboard模式，飞机起飞。飞机起飞稳定后，控制终端输入1，执行跟踪指令。</p><p>   降落时，操控遥控器退出offboard模式，油门慢慢降低，飞机降落进入怠速，上锁。</p><h2 id="室内避障"><a href="#室内避障" class="headerlink" title="室内避障"></a>室内避障</h2><p>启动指令roslaunch p450_experiment astar_onboard.launch，检查飞机各项数据；再启动避障指令，在终端输入0选择命令控制模式，输入1起飞指令。</p><p>遥控器在定点模式下解锁，然后切换到offboard模式，飞机起飞。飞机起飞稳定后，在rviz界面中选择3D NavGoal，界面中选择一个点作为目标点，系统会自动生成路径并沿着该路径飞行。</p><p>降落时，操控遥控器退出offboard模式，油门慢慢降低，飞机降落进入怠速，上锁。</p><h1 id="实操环节个人心得"><a href="#实操环节个人心得" class="headerlink" title="实操环节个人心得"></a>实操环节个人心得</h1><ul><li><p>每次执行新的任务时，都应该对飞控执行reboot指令，确保飞控处于正常的状态。飞机解锁前，也应该在地面站中查看飞机的位置，模式等是否为自己所需要的状态。</p></li><li><p>飞机降落，应该在定点模式下进行，在确保飞机上锁后方可解锁油门。</p></li><li><p>单目相机无法识别时，可以通过拔插单目相机的方法来解决。</p></li><li><p>遥控器操控较敏感时，需要注意拨动的力度，两个手指轻轻拨动。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> UAV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实操 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog日常踩坑</title>
      <link href="/posts/ca708840.html"/>
      <url>/posts/ca708840.html</url>
      
        <content type="html"><![CDATA[<p>本文主要是记录博客网站搭建过程中遇到的各种问题以及如何进行修改，集中在主题修改和网站加速这些部分，还是踩了不少坑的，记录下来方便查询。</p><h1 id="hexo博客："><a href="#hexo博客：" class="headerlink" title="hexo博客："></a><strong>hexo博客：</strong></h1><ul><li><a href="https://hexo.io/zh-cn/docs/configuration.html">hexo 官方配置</a>，可以详细看到hexo博客如何配置</li><li>url跟站点地图相关，需要填写github page网址或者自定义域名</li><li>blog文件放在source的<code>_posts</code>文件夹中，在obsidian中将该文件夹作为库打开，子文件夹不影响md文件最后的发布。</li><li>permalink网页永久链接，影响网页发布的地址，网页发布可以在<code>public</code>文件夹中看到，采用把网页放在<code>posts</code>文件夹中，并结合<code>abbrlink</code>重命名，简洁方便</li><li>hexo迁移，可直接复制整个文件过去，然后确保<code>node.js</code>和<code>git</code>成功安装，随便找个文件夹在 <code>git bash</code> 中执行 <code>npm install -g hexo-cli</code>，这一步是安装<code>hexo</code>。执行<code>hexo init</code>(这一步已经复制了也许不用)，与github进行ssh就不讲了。可以将之前的.deploy_git和.git文件删除，执行<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code> 进行预览</li><li>执行了github actions自动化操作，方便在上传相关修改，以及在不同设变之间进行迁移的工作。<a href="https://haoqin.vip/posts/519a1be4">Github Actions &amp;&amp; Cloudflare Pages 部署 | Haoqin`s Blog</a></li><li>在blog目录文件夹处打开Git Bash界面，可以执行命令<code>hexo new 文件名</code>，可以在已经配置好路径的情况下，实现在对应的年月文件夹里创建初始模板的文件。</li></ul><h1 id="matery主题："><a href="#matery主题：" class="headerlink" title="matery主题："></a><strong>matery主题：</strong></h1><ul><li>在<a href="https://www.materialpalette.com/colors">Material Design Colors </a>中进行颜色的选择，自定义网页各部分的颜色</li><li>live2d需要在主题source中添加live2d-widget文件夹，对应layout文件夹中layout.ejs添加依赖等，根据自己的需要修改<code>autoload.js</code>文件的cdn路径</li><li><code>\themes\matery\source\css\matery.css</code>网页颜色等进行修改：<code>.bg-cover.container</code>和<code>bg-cover .description</code>对应首页标题及诗词（文章标题）颜色</li><li>评论系统的添加，<a href="https://cimoc.cn/2022/02/16/hexo-next-valine-leancloud/#%E4%B8%80%E3%80%81%E6%B3%A8%E5%86%8C">Hexo-Next/Matery 基于 LearnCloud 添加 Valine 评论系统 | Cimoc</a></li><li>使用了主题旧版本，所以没有文章更新日期，bg-cover-content.ejs和zh-CN.yml中添加更新日期对应内容。</li><li>音乐配置文件在Hexo\source_data文件中，并没有放在matery主题文件中</li><li>从安全性和方便性的角度出发，将valine换成waline，方便操作，将waline.ejs中的内容替代到valine.ejs中。具体配置可以参考[快速上手 | Waline]和<a href="https://hubojing.github.io/2022/01/14/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2%E4%B8%BAWaline%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">博客更换为Waline评论系统 | 靖待的技术博客 </a></li><li>鸿蒙字体的引入，在<code>my.css</code>文件中粘贴鸿蒙字体对应css文件，全局引用。<a href="https://gahotx.cn/posts/13a9d850.html">免费商用字体-HarmonyOS Sans | Gahotx’s blog</a></li><li>https网站不可以引用http的资源</li><li>代码块更新操作<br>  1、在hexo根目录执行<code>npm uninstall hexo-prism-plugin</code>卸载原有的插件<br>  2、hexo的配置为：<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>3、主题进行相关配置：<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">code</span><span class="token punctuation">:</span>  <span class="token key atrule">lang</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment"># 代码块是否显示名称</span>  <span class="token key atrule">copy</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment"># 代码块是否可复制</span>  <span class="token key atrule">shrink</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment"># 代码块是否可以收缩</span>  <span class="token key atrule">break</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment"># 代码是否折行</span>    <span class="token key atrule">css</span><span class="token punctuation">:</span><span class="token key atrule">prism</span><span class="token punctuation">:</span> /libs/prism/prism.min.css  <span class="token key atrule">js</span><span class="token punctuation">:</span>    <span class="token key atrule">prism</span><span class="token punctuation">:</span> /libs/prism/prism.min.js    <span class="token key atrule">codeblock</span><span class="token punctuation">:</span> /libs/codeBlock/codeBlockFuction.js    <span class="token key atrule">codelang</span><span class="token punctuation">:</span> /libs/codeBlock/codeLang.js    <span class="token key atrule">codecopy</span><span class="token punctuation">:</span> /libs/codeBlock/codeCopy.js    <span class="token key atrule">codeshrink</span><span class="token punctuation">:</span> /libs/codeBlock/codeShrink.js<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>4、在主题的libs文件夹中添加codeBlock和prism文件夹；<br>5、_partial文件夹中添加codeblock.ejs文件，若原有post.ejs中有相关配置进行删除<br>6、对post-detail.ejs进行配置：<pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs"> <span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%</span><span class="token language-javascript"> <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>prismjs <span class="token operator">&amp;&amp;</span> config<span class="token punctuation">.</span>prismjs<span class="token punctuation">.</span>enable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </span><span class="token delimiter punctuation">%></span></span>        <span class="token comment">&lt;!-- 是否加载使用自带的 prismjs. --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%-</span><span class="token language-javascript"> <span class="token function">url_for</span><span class="token punctuation">(</span>theme<span class="token punctuation">.</span>libs<span class="token punctuation">.</span>css<span class="token punctuation">.</span>prism<span class="token punctuation">)</span> </span><span class="token delimiter punctuation">%></span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%</span><span class="token language-javascript"> <span class="token punctuation">&#125;</span> </span><span class="token delimiter punctuation">%></span></span>        <span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%</span><span class="token language-javascript"> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>code<span class="token punctuation">.</span>break<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </span><span class="token delimiter punctuation">%></span></span>        <span class="token comment">&lt;!-- 代码块折行 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">            <span class="token selector">code[class*="language-"], pre[class*="language-"]</span> <span class="token punctuation">&#123;</span> <span class="token property">white-space</span><span class="token punctuation">:</span> pre-wrap <span class="token important">!important</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>        <span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%</span><span class="token language-javascript"> <span class="token punctuation">&#125;</span> </span><span class="token delimiter punctuation">%></span></span><span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%-</span><span class="token language-javascript"> <span class="token function">partial</span><span class="token punctuation">(</span><span class="token string">'_partial/codeblock'</span><span class="token punctuation">)</span> </span><span class="token delimiter punctuation">%></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="网站加速："><a href="#网站加速：" class="headerlink" title="网站加速："></a><strong>网站加速：</strong></h1><ul><li>将 cdn.jsdelivr.net 更换为 fastly.jsdelivr.net———<a href="https://www.hurbai.com/jishu/697">jsdelivr cdn 挂了不能访问替代方案 - 大灰hurbai</a></li><li>看起来挺方便的，还没有尝试，<a href="https://github.com/PipecraftNet/jsdelivr-auto-fallback">GitHub - PipecraftNet/jsdelivr-auto-fallback: 修复 cdn.jsdelivr.net 无法访问的问题</a></li><li>（已放弃，免费但不够方便）项目中静态文件替换,使用阿里云<a href="https://unicloud.dcloud.net.cn/">uniCloud云存储</a>— <a href="https://blog.csdn.net/weixin_45525272/article/details/124820135">jsdelivr cdn大陆挂了不能访问替代方案_流楚丶格念的博客-CSDN博客</a></li><li>github图床外网访问慢，使用dogecloud存储空间作为图床</li><li>github可以直接登录vercel，进行仓库导入，部署到vercel（速度跟github page五五开）</li><li>vercel国内速度堪忧，自定义域名后尝试cloudflare加速</li><li><a href="https://cloud.tencent.com/developer/article/1926007">腾讯云静态网站托管</a>，国内打开速度很快，静态网站托管天然支持 CDN 加速，流量的费用是0.21/GB，自定义域名需要备案支持。</li><li><a href="https://gahotx.cn/posts/78431b52.html">教你如何“榨干”免费的多吉云 | Gahotx’s blog</a>，使用多吉云加速网站</li><li>网站进行cdn加速，多次出现Forward Loop Detect提示，怀疑是重定向问题，将网页域名绑定为二级域名，暂时解决了。<a href="https://www.zywvvd.com/notes/hexo/website/7-hexo-speed-up/hexo-speed-up/">Hexo -7- Github源七牛云CDN加速教程（详细） - 又见苍岚</a></li><li>放弃了cdn网页加速，只让静态资源进行cdn加速。</li><li>waline系统访问困难（疑似DNS污染），考虑绑定了自定义域名。</li></ul><h1 id="网站域名："><a href="#网站域名：" class="headerlink" title="网站域名："></a><strong>网站域名：</strong></h1><ul><li>谷歌站点添加失败，放弃网址前缀，采用域名dns验证</li><li>阿里云购买域名，进行备案发现需要有云服务支持（3个月服务器等）</li><li>腾讯每日特价服务器30元/3月，购买服务器进行备案，腾讯备案服务体验不错，最后一步备案承诺书需要按手印</li><li>使用cloudflare加速，因此使用cloudflare管理域名解析（改用多吉云加速后放弃此方法）；更新：为了方便使用cloudflare pages，将相关的域名解析工作交给cloudflare。</li><li>备案期间，域名需要暂停解析，停止访问，选择导出dns解析文件，等待备案完成。</li><li>icp备案在6月1日拿到，也算作个儿童节礼物，备案需要一个星期到10天左右。</li><li>公安备案域名，广州本地备案速度快（2-3天），有问题会驳回的，注意看下备案平台的通知信息。注意上传照片规范性，网站类型选择了非交互式及开通www服务，希望无问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matery </tag>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Introduction to Aerial Robotics</title>
      <link href="/posts/43466178.html"/>
      <url>/posts/43466178.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.coursera.org/learn/robotics-flight/home/week/1">Robotics: Aerial Robotics</a>是由宾夕法尼亚大学Vijay Kuma开展的无人机课程，本文是1.1节 introduction 和1.2节 Energetics and System Design 的学习内容记录。</p><h1 id="1-1-introduction"><a href="#1-1-introduction" class="headerlink" title="1.1 introduction"></a>1.1 introduction</h1><p><strong>无人机</strong>常见的几种称呼：</p><ul><li>Unmanned Aerial Vehicles(UAV)，无人驾驶飞机</li><li>Drone，无人机</li><li>Quadrotors，四旋翼无人机</li></ul><p>固定翼无人机无法实现在空中悬停<br>平移运动涉及横滚和俯仰，四旋翼无人机具有6个自由度，三个平移方向和三个旋转方向</p><p>无人机必备的<strong>关键元素</strong>：</p><ul><li>状态估计(State Estimation)：飞行器估计自身位置，朝向和速度的能力</li><li>控制(Cnotrol): 计算控制指令，根据状态信息等给出控制指令</li><li>制图(Mapping):制图能力，绘制所在环境的地图</li><li>规划(Planning): 在已知障碍物和目的地的情况下，测算出点到点的安全路径</li></ul><p><strong>状态估计</strong>：</p><ul><li>目的是能够获得位置与速度的可靠估计</li><li>良好的环境：实验室中使用运动捕捉相机，其要点是通过挂载在机器人上的反射标记，相机可以估计每个反射标记的位置；外部环境下使用GPS</li><li>一般采用其它传感器完成这一过程，如相机和激光测距仪。传感器给出障碍物的距离。同时无人机具有惯性测量单元（IMU),能够估计其由一个位置到另一个位置的运动，得到△x，即获取坐标信息并估计运动，完成实时定位和地图构建<img src="https://image.haoqin.vip/2022/05/202205281005517.png" alt=""></li><li>在仅有一个相机的情况下，需要使用路标进行指示，比如在地毯上出现的AprilTag路标。</li></ul><p>习题部分：<br><strong>Q:</strong> An Inertial Measurement Unit (IMU) is an important sensor used in aerial robotics. A typical IMU will contain an accelerometer and a rate gyro. Which of the following information does a robot get from an IMU? (Select all that apply. Choose only quantities that are directly reported by the IMU. Do not include quantities that can be computed from the IMU measurements but cannot be obtained directly. Additional research to find information about IMUs is allowed and encouraged!)<br><strong>A:</strong> Linear acceleration, Angular velocity</p><p><strong>Q:</strong>  What does Simultaneous Localization And Mapping (SLAM) software do? (Select all that applies.)<br><strong>A:</strong> Estimates the location of features in the environment;  Estimates the position and orientation of the robot with respect to the environment</p><h1 id="1-2-Energetics-and-System-Design"><a href="#1-2-Energetics-and-System-Design" class="headerlink" title="1.2 Energetics and System Design"></a>1.2 Energetics and System Design</h1><p>Basic Mechanics</p><ul><li>电机旋转产生推力( thrust force ) 抵消无人机自身重力的存在，同时电机的旋转产生的阻力需要电机去客服，推力和阻力都跟速度存在一个二次方程的关系。<br><img src="https://image.haoqin.vip/2022/06/202206072204744.png" alt=""></li><li>电机悬停时存在的合力和合力矩的情况，质心确定，各旋翼的推力与到质心的距离构成了力矩。<br><img src="https://image.haoqin.vip/2022/06/202206072209846.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> UAV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robotics:Aerial Robotics </tag>
            
            <tag> course </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专利基础知识</title>
      <link href="/posts/d3461e41.html"/>
      <url>/posts/d3461e41.html</url>
      
        <content type="html"><![CDATA[<p>硕士阶段主要接触的专利类型有发明专利和实用新型专利，在21级专业学位硕士毕业要求中与专利相关的内容为下：</p><ol><li>申请（受理）发明专利1项；</li><li>授权实用新型专利1项，或授权软件版权1件，同时在中国科技论文统计源期刊上公开发表学术论文1篇；</li></ol><p>本文将对专利申请的基础知识进行简单梳理，初步研判进行算法类专利开发的可行性，后续将会进一步针对无人机的相关具体专利进行调研。</p><h1 id="专利申请流程"><a href="#专利申请流程" class="headerlink" title="专利申请流程"></a>专利申请流程</h1><p>发明专利和实用新型专利的时间流程有所不同，发明专利授权所需要的时间往往远大于实用新型所需要的时间，各自的时间流程简要介绍如下：</p><ul><li><strong>实用新型专利</strong><br>专利申请—受理通知书—初步审查—授权通知—颁发专利证书，整个时间约<strong>10个月</strong>左右。<br>在提交申请书后，约一个星期收到专利局“专利受理通知书”，出专利申请号。从申请之日起，约10个月收到专利局“授权通知书”。按规定交纳证书费后，约2个月发《专利证书》。整个申请时间大概要一年，有效期为10年(申请日起算)。具体<strong>流程图</strong>参考如下：<img src="https://image.haoqin.vip/2022/05/202205212300228.png" alt=""></li></ul><ul><li><strong>发明专利</strong><br>发明专利申请-&gt;初步审查-&gt;公开-&gt;实质审查-&gt;授予专利权，整个流程需要的时间约为<strong>2-3年</strong>。<br>递交给国家知识产权局→→受理并下发受理通知书（1周）→→初步审查阶段（3-4个月）→→下发初步审查合格通知→→进入公示阶段（自初审合格到公示2个月）→→进入实审阶段→→一审通知(自公示到一审9个月左右)→→3个月左右出第一次审查意见→→二审通知→→N审通知→→授权与否。具体<strong>流程图</strong>参考如下：<img src="https://image.haoqin.vip/2022/05/202205212300699.png" alt=""></li></ul><h1 id="专利申请文件"><a href="#专利申请文件" class="headerlink" title="专利申请文件"></a>专利申请文件</h1><p>专利申请文件主要包括说明书（文字、附图）、权利要求书和摘要（文字、附图）三个部分，对这个三个部分的内容进行简单的介绍，详见参考内容中华工专利事务中心执业代理师<u>江裕强</u>的文件分享。</p><h2 id="说明书"><a href="#说明书" class="headerlink" title="说明书"></a>说明书</h2><p>说明书：对发明作出清楚、完整的说明，以所属技术领域的技术人员能够实现为准。说明书的组成部分为下：</p><ul><li>技术领域</li><li>背景技术</li><li>发明内容——技术问题、方案及有益效果</li><li>附图说明</li><li>具体实施方式</li></ul><h2 id="权利要求书"><a href="#权利要求书" class="headerlink" title="权利要求书"></a>权利要求书</h2><p>权利要求书是记载发明或者实用新型的技术特征，限定<strong>专利保护范围</strong>的法律文件。该文件中的权利要求是由发明或者实用新型的技术特征组成的。该发明或者实用新型被授予专利权后，专利权的保护范围以权利要求的内容为准。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>摘要是对说明书公开内容的概括，它仅提供一种技术情报，不具有法律作用。摘要应当写明发明或者实用新型的技术领域，需要解决的技术问题，主要技术特征和用途。</p><h1 id="算法类专利"><a href="#算法类专利" class="headerlink" title="算法类专利"></a>算法类专利</h1><p>算法本身是无法进行专利申请的，若将算法原理与客观存在的实体特征相结合，可以解决一定的技术问题，产生有益的技术效果的，则属于专利保护的客体，即如果申请专利，需要抽象出算法中体现的技术思想，注意是技术思想，即这个算法要<strong>通过技术手段，解决技术问题，取得技术效果</strong>。</p><p>算法类专利申请的显著特征在于，发明构思通常会与公式推导、算法改进有关，如果不增加技术性描述和限定，通常会存在被认为属于<u>纯数学推导计算</u>的风险，这就要求在撰写权利要求书时注意加入适当的技术性限定特征来突出方案的技术性。加入技术性的限定特征一方面可以考虑在权利要求中明确<u>执行主体</u>，例如通过计算机、处理器等数据/信息处理设备来执行控制和/或处理，另一方面更要考虑加入与算法技术方案自身相关的一些技术特征。</p><p>所以算法与实体特征结合显得很重要，例如，可以依据该算法的数据处理流程、信号流转过程，<strong>将该算法步骤转换为多个有物理意义的技术方法步骤</strong>，并且说明该方法步骤可以达到的技术效果，则可以解决一定的技术问题，产生有益的技术效果的。</p><p>综上所述，算法类专利是可行的，但其专利申请的门槛较高，不仅要满足原有的创新点以及文件规范外，还要注意其<strong>技术特征</strong>的加入，在进行相关描述时可能得借助专利代理机构的把关。</p><p>专利信息的查询网站：<a href="https://cpquery.cponline.cnipa.gov.cn/">https://cpquery.cponline.cnipa.gov.cn</a></p><h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ul><li>骏思知识产权，<a href="https://www.zhihu.com/question/406998884/answer/1350013220">申请专利需要多长时间？</a></li><li>江裕强，<a href="https://mailscuteducn-my.sharepoint.com/:b:/g/personal/201730052431_mail_scut_edu_cn/ESEsfX-8iYFErBWB2Eud6t8BnhYm1mF-iYVpd8b3BYBrsA?e=FcRqz9">如何撰写专利文件？</a></li><li>颜一，<a href="https://www.zhihu.com/question/407578081/answer/1353814913">关于算法设计怎么撰写专利？</a></li><li>刚刚聊专利，<a href="https://zhuanlan.zhihu.com/p/473154516">算法类专利申请的撰写思路 </a></li></ul>]]></content>
      
      
      <categories>
          
          <category> UAV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人机基础物理概念</title>
      <link href="/posts/5d553541.html"/>
      <url>/posts/5d553541.html</url>
      
        <content type="html"><![CDATA[<p>本文对无人机飞行的一些基本概念进行梳理记录，动力学方程相关暂不涉及。</p><h1 id="简单的垂直与水平分析"><a href="#简单的垂直与水平分析" class="headerlink" title="简单的垂直与水平分析"></a>简单的垂直与水平分析</h1><h2 id="Vertical-Motion"><a href="#Vertical-Motion" class="headerlink" title="Vertical Motion"></a>Vertical Motion</h2><p>四旋翼无人机的旋翼工作产生升力，升力与重力相等时，合力为零，此时无人机处于悬停状态（<strong>hover</strong>）。<br>增大无人机四旋翼推力（速度），可以实现无人机爬升（<strong>climb</strong>）。<br>减小无人机四旋翼推力（速度），可以实现无人机下降（<strong>descend</strong>）。</p><h2 id="Turning-or-Rotating"><a href="#Turning-or-Rotating" class="headerlink" title="Turning or Rotating"></a>Turning or Rotating</h2><p>无人机的旋转与各旋翼的旋转方向和旋转速度相关，两个相邻的电机以相反的方向旋转，两个相反的电机沿同一方向旋转。角动力值可以用<strong>角速度乘以惯性矩</strong>得到。<br><img src="https://image.haoqin.vip/2022/05/202205212120854.png" alt=""><br>红色的旋翼呈逆时针旋转，绿色的旋翼呈顺时针旋转，如图所示。当1和3同时减小，2和4增大，保持无人机的升力依旧等于重力，实现无人机方向的改变</p><h1 id="空间姿态与位置"><a href="#空间姿态与位置" class="headerlink" title="空间姿态与位置"></a>空间姿态与位置</h1><h2 id="基本描述"><a href="#基本描述" class="headerlink" title="基本描述"></a>基本描述</h2><p>欧拉角是描述旋转的一种方式，那姿态角呢？姿态角属于欧拉角的一种特殊形式，我们一般定义姿态角为<strong>偏航（Yaw），俯仰（Pitch），横滚（Roll）</strong>。在不同的载体坐标系里，姿态角对应也不一样。<br>四旋翼无人机有6个自由度，分别为前后、上下、左右移动，横滚、俯仰、偏航旋转，而控制是从四个方面来进行的：升降通道（Thrust），横滚角（Roll）控制通道，俯仰角控制通道（Pitch）和偏航角控制通道（Yaw）。<br>下面三张动图呈现的是前后、左右、旋转的效果：</p><p><img src="https://image.haoqin.vip/2022/05/202205211652933.gif" alt=""><img src="https://image.haoqin.vip/2022/05/202205211652934.gif" alt=""><img src="https://image.haoqin.vip/2022/05/202205211652935.gif" alt=""></p><h2 id="运动姿态实现"><a href="#运动姿态实现" class="headerlink" title="运动姿态实现"></a>运动姿态实现</h2><p>以无人机质心为原O，正前方为X轴正方向，右侧方为Y轴正方向，竖直向上为Z轴正方向建立机体坐标系，分析各种运动姿态原理，如图所示<br><img src="https://image.haoqin.vip/2022/05/202205212123000.png" alt=""></p><p>升降运动：在图a中，同时增大无人机四个旋翼转速，使得总升力大于无人机整体重量后无人机将沿着Z轴垂直上升，反之，减小四个旋翼转速使总升力小于无人机自身重量后，无人机将垂直降落。在无外界干扰的情况下当总升力等于机体重量时无人机将保持悬停。</p><p>前后运动（<strong>pitch</strong>）：如图b所示，3、4号旋翼转速增大，1、2号旋翼转速保持，前后升力差会导致无人机出现“前低后高”的姿态，旋翼推力在<strong>X轴正方向的分力</strong>将驱动无人机前进；同理当1、2号旋翼转速增大，3、4号旋翼转速不变时无人机将会后退。</p><p>左右移动（<strong>roll</strong>）：与前后移动原理相同，在图c中，1、4号旋翼转速增大时无人机向左移动，2、3号旋翼转速增大时无人机向右移动。</p><p>偏航运动（<strong>yaw</strong>）：如图d所示，当一对正转旋翼与一对反转旋翼转速相同时，产生的扭矩则相互抵消，无人机不旋转。和当1、3号旋翼转速增大而2、4号旋翼转速不变时，1、3号旋翼对机体产生的扭矩大于2、4号旋翼的反扭矩，因此无人机将绕Z轴进行逆时针旋转；反之，当2、4号旋翼转速大于1、3号旋翼转速时，无人机将绕Z轴顺时针旋转。</p><h2 id="讲解视频"><a href="#讲解视频" class="headerlink" title="讲解视频"></a>讲解视频</h2><p>在MATLAB关于无人机仿真和控制的学习内容–<a href="https://www.youtube.com/watch?v=hGcGPUqB67Q">Drone Simulation and Control, Part 1: Setting Up the Control Problem - YouTube</a>中，对无人机控制的基本框架进行一个简要介绍，涉及控制器、执行器以及传感器，中间融入算法和预期目标等。<img src="https://image.haoqin.vip/2022/05/202205212254120.png" alt=""><br>视频中尤其重点介绍了无人机几种姿态（pitch, roll, yaw, thrust) 的演示过程，讲解得通俗易懂。视频中还说明无人机同向螺旋桨为何要对向放置，涉及重心以及偏航的问题。在讲解无人机左右平移时，展示了图片，说明螺旋桨推力分解为抵消重力的分力和左右移动的分力，对上文的一个图示补充。<img src="https://image.haoqin.vip/2022/05/202205212257273.png" alt=""></p><h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p>Jared Maltos，<a href="http://ffden-2.phys.uaf.edu/webproj/211_fall_2018/J-Rod_Maltos/physics_4th.html">The Flight Physics of Quadcopter Drones</a><br>Rhett Allain，<a href="https://www.wired.com/2017/05/the-physics-of-drones/">How Do Drones Fly? Physics, of Course!</a><br>田家大院院士，<a href="https://zhuanlan.zhihu.com/p/353334071">旋翼无人机的飞行原理是什么？</a><br>MATLAB，<a href="https://www.youtube.com/watch?v=hGcGPUqB67Q">Drone Simulation and Control, Part 1: Setting Up the Control Problem - YouTube</a></p>]]></content>
      
      
      <categories>
          
          <category> UAV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动力学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客首文</title>
      <link href="/posts/71e2287b.html"/>
      <url>/posts/71e2287b.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>爱折腾的心可能是我搭建博客的主因吧，看到师兄和网上其他人的博客，心中就冒出了自己也搭建一个博客的想法，有了想法，就会去做。</p></li><li><p>搭建博客的过程还是有点曲折的，环境的搭建其实还好，hexo博客搭建网上的教程挺多的。而主题的选择这里游离于偷懒和自己动手之间，反复横跳浪费了不少的时间。</p><p>主题最后参考了MUYIio的github项目，对其中的个人信息等部分进行修改得到了现在的博客，这个过程还是有点麻烦的，因为有些他修改的地方你不一定知道修改了哪里，很容易各种地方报错。</p></li><li><p><strong>MUYIio对应博客教程地址：</strong></p></li></ul><p><a href="https://www.yshawlon.cn/1.html" title="Github + Hexo 搭建个人博客超详细教程">《Github + Hexo 搭建个人博客超详细教程》</a>   ( By   yzhao )</p><ul><li><p>现在博客的想法也很简单，记录自己的学习上的相关东西，相当于一个变相的笔记整理；然后记录一下自己生活工作中遇到的问题的处理方法，记录一些生活的瞬间和感悟。</p><p>不过还是想法，能不能做到也挺难说的，毕竟人比较懒，喜欢折腾，但坚持总是不易的。</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>初学者搭建博客还是老老实实按着教程来吧，个性化的东西可以慢慢来，走捷径一堆报错也难搞~</p><p>希望自己能够有所坚持，不要荒废这个博客，好好学习，天天向上！</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
